import java.util.concurrent.TimeUnit

allprojects { project ->
    configurations.all {
        exclude group: 'junit', module: 'junit'
        exclude group: 'io.qameta.allure', module: 'allure-junit4'
        exclude group: 'io.qameta.allure', module: 'allure-junit4-aspect'
        exclude group: 'io.qameta.allure', module: 'allure-testng'
    }
    ext.testsResults = []
    ext.duration = "00:00:00"
    ext.reportFile = ""

    tasks.withType(Test) {
        testLogging {
            showStandardStreams true
            exceptionFormat "FULL"
            events "PASSED", "SKIPPED", "FAILED"
        }

        afterSuite() { desc, result ->
            if (desc.parent) return
            // Сохраняем в переменную время выполнения тестов
            rootProject.duration = convertMs(result.endTime - result.startTime)
            String summary = "${project.name}:${name} results: ${result.resultType} " +
                    "(" +
                    "${result.testCount} tests, " +
                    "${result.successfulTestCount} successes, " +
                    "${result.failedTestCount} failures, " +
                    "${result.skippedTestCount} skipped" +
                    ") " +
                    "in ${rootProject.duration}" +
                    "\n" +
                    "Report file: ${reports.html.entryPoint}"

            //Сохраняем файл с отчетом в переменную
            rootProject.reportFile = reports.html.entryPoint
            if (result.resultType == TestResult.ResultType.SUCCESS) {
                rootProject.testsResults.add(0, summary)
            } else {
                rootProject.testsResults += summary
            }
        }
    }
}

gradle.buildFinished {
    def allResults = rootProject.ext.testsResults

    if (!allResults.isEmpty()) {
        printResults allResults
        //Добавляем div с реальным временем выполнения прогона
        //Добавляем тут, потому что только в этом месте есть гарантии что файл уже существует
        addRealDuration(rootProject.ext.reportFile, rootProject.ext.duration)
    }
}

private static void printResults(allResults) {
    def maxLength = allResults*.readLines().flatten().collect { it.length() }.max()

    println "┌${"${"─" * maxLength}"}┐"

    println allResults.collect {
        it.readLines().collect {
            "│" + it + " " * (maxLength - it.length()) + "│"
        }.join("\n")
    }.join("\n├${"${"─" * maxLength}"}┤\n")

    println "└${"${"─" * maxLength}"}┘"
}

private static void addRealDuration(file, duration) {
    if (file.exists()) {
        new FileWriter(file.getAbsolutePath(), true).with {
            write('<div class="infoBox" id="realDuration">'+duration+'</div>')
            flush()
        }
    }
}

private static String convertMs(long millisecondsToConvert) {
    long hours = TimeUnit.MILLISECONDS.toHours(millisecondsToConvert);
    long minutes = TimeUnit.MILLISECONDS.toMinutes(millisecondsToConvert) % TimeUnit.HOURS.toMinutes(1);
    long seconds = TimeUnit.MILLISECONDS.toSeconds(millisecondsToConvert) % TimeUnit.MINUTES.toSeconds(1);

    return String.format("%02d:%02d:%02d", Math.abs(hours), Math.abs(minutes), Math.abs(seconds));
}