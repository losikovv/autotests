syntax = "proto3";

package shippingcalc;
option go_package = "gitlab.sbmt.io/paas/content/operations/shippingcalc/pkg/server/grpc/shippingcalc";
import "google/protobuf/timestamp.proto";
option java_multiple_files = true;

service Shippingcalc {
	// Создать стратегию
	rpc CreateStrategy(CreateStrategyRequest) returns (CreateStrategyResponse);
	// Обновить стратегию
	rpc UpdateStrategy (UpdateStrategyRequest) returns (UpdateStrategyResponse);
	// Прикрепить стратегию к магазину
	rpc BindStrategy (BindStrategyRequest) returns (BindStrategyResponse);
	// Открепить стратегию от магазина
	rpc UnbindStrategy (UnbindStrategyRequest) returns (UnbindStrategyResponse);
	// Создать правило привязки стратегии (эти правила используются автобиндером)
	rpc CreateBindingRule (CreateBindingRuleRequest) returns (CreateBindingRuleResponse);
	// Обновить правило привязки стратегии (эти правила используются автобиндером)
	rpc UpdateBindingRule (UpdateBindingRuleRequest) returns (UpdateBindingRuleResponse);
	// Получить правила привязки стратегий (эти правила используются автобиндером)
	rpc GetBindingRules (GetBindingRulesRequest) returns (GetBindingRulesResponse);
	// Удалить правило привязки стратегии (эти правила используются автобиндером)
	rpc DeleteBindingRule (DeleteBindingRuleRequest) returns (DeleteBindingRuleResponse);
	// Получить все существующие стратегии
	rpc GetStrategies (GetStrategiesRequest) returns (GetStrategiesResponse);
	// Получить стратегию по идентификатору
	rpc GetStrategy (GetStrategyRequest) returns (GetStrategyResponse);
	// Получить стратегии для магазина
	rpc GetStrategiesForStore (GetStrategiesForStoreRequest) returns (GetStrategiesForStoreResponse);
	// Удалить стратегию по идентификатору
	rpc DeleteStrategy (DeleteStrategyRequest) returns (DeleteStrategyResponse);
	// Создать скрипт
	rpc CreateScript (CreateScriptRequest) returns (CreateScriptResponse);
	// Обновить скрипт
	rpc UpdateScript (UpdateScriptRequest) returns (UpdateScriptResponse);
	// Получить скрипт по идентификатору
	rpc GetScript (GetScriptRequest) returns (GetScriptResponse);
	// Получить все существующие скрипты
	rpc GetScripts (GetScriptsRequest) returns (GetScriptsResponse);
	// Получить результаты теста скрипта
	rpc GetScriptTestResults (GetScriptTestResultsRequest) returns (GetScriptTestResultsResponse);
	// Удалить скрипт по идентификатору
	rpc DeleteScript(DeleteScriptRequest) returns (DeleteScriptResponse);
	// Получить стоимость доставки
	rpc GetDeliveryPrice (GetDeliveryPriceRequest) returns (GetDeliveryPriceResponse);
	// Получить минимальные корзины по списку
	rpc GetMinCartAmounts (GetMinCartAmountsRequest) returns (GetMinCartAmountsResponse);
	// Наиболее выгодные условия доставки для магазинов
	rpc GetDeliveryConditions (GetDeliveryConditionsRequest) returns (GetDeliveryConditionsResponse);
	// Установить сразу все интервалы switchback-тестов
	rpc SetSwitchbacks (SetSwitchbacksRequest) returns (SetSwitchbacksResponse);
	// Получить все интервалы switchback-тестов
	rpc GetSwitchbacks (GetSwitchbacksRequest) returns (GetSwitchbacksResponse);
	// Получить все параметры для surge
	rpc GetSurgeParameters (GetSurgeParametersRequest) returns (GetSurgeParametersResponse);
	// Установить параметры для surge
	rpc SetSurgeParameters (SetSurgeParametersRequest) returns (SetSurgeParametersResponse);
	// Удалить параметры surge
	rpc DeleteSurgeParameters (DeleteSurgeParametersRequest) returns (DeleteSurgeParametersResponse);
}

enum DeliveryType {
	NONE = 0;
	SELF_DELIVERY = 1;
	COURIER_DELIVERY = 2;
	// aka B2B courier delivery
	B2B = 3;
	B2B_SELF_DELIVERY = 4;
}

message CreateStrategyRequest {
	// Правила
	repeated NewRuleObject rules = 1;
	// Автор
	string creator_id = 2;
	// Наименование стратегии
	string name = 3;
	// Признак глобальной стратегии
	bool global = 4;
	// Приоритет (актуально только для глобальной стратегии)
	uint32 priority = 5;
	// Произвольное описание стратегии
	string description = 6;
	// Тип доставки
	DeliveryType delivery_type = 7;
	// Список правил для суммы минимальной корзины
	repeated MinCartRuleObject min_cart_rules = 8;
}

message CreateStrategyResponse {
	// Идентификатор стратегии
	uint32 strategy_id = 1;
}

message UpdateStrategyRequest {
	// Идентификатор стратегии
	uint32 strategy_id = 1;
	// Правила
	repeated NewRuleObject rules = 2;
	// Автор изменений?
	string creator_id = 3;
	// Наименование стратегии
	string name = 4;
	// DEPRECATED: Признак глобальной стратегии
	bool global = 5 [deprecated = true];
	// Приоритет (актуально только для глобальной стратегии)
	uint32 priority = 6;
	// Произвольное описание стратегии
	string description = 7;
	// Тип доставки
	DeliveryType delivery_type = 8;
	// Список правил для суммы минимальной корзины
	repeated MinCartRuleObject min_cart_rules = 9;
}

message NewRuleObject {
	// Идентификатор скрипта
	uint32 script_id = 1;
	// Значения парамеров скрипта
	string script_param_values = 2;
	// Условия применения правила
	repeated NewConditionObject conditions = 3;
	// Приоритет правила в рамках стратегии
	int32 priority = 4;
}

message MinCartRuleObject {
	// Минимальная сумма корзины
	uint64 min_cart_value = 1;
	// Условия применения правила
	repeated NewConditionObject conditions = 2;
	// Приоритет правила в рамках стратегии
	int32 priority = 3;
}

enum ConditionType {
	ALWAYS = 0;
	FIRST_N_ORDERS = 1;
	ORDER_VALUE_RANGE = 2;
	AB_TEST_ENTRANCE = 3;
	ORDER_DISTANCE_RANGE = 4;
	PLATFORMS = 5;
	REGISTERED_AFTER = 6;
	ON_DEMAND = 7;
	CLIENT_API = 8;
}

message NewConditionObject {
	// Тип условия
	ConditionType condition_type = 1;
	// Параметры
	string params = 2;
}

message UpdateStrategyResponse {
	// Список идентификаторов правил?
	repeated uint32 rules_id = 1;
	// Список идентификаторов правил для минимальной корзины
	repeated uint32 min_cart_rules_id = 2;
}

message BindStrategyRequest {
	// Идентификатор стратегии
	uint32 strategy_id = 1;
	// Список привязок к стратегии
	repeated StrategyBinding binds = 2;
	// Раньше этот флаг указывал, удалять ли существующие привязки перед добавлением
	// Теперь удалять привязки запрещено. Можно лишь заменить стратегию в привязке
	bool replace_all = 3 [deprecated = true];
}

message StrategyBinding {
	// Идентификатор магазина
	string store_id = 1;
	// Идентификатор тенанта
	string tenant_id = 2;
	// Тип доставки
	DeliveryType delivery_type = 3;
}

message BindStrategyResponse {
	// Представление стратегии
	StrategyView strategy = 1;
}

message StrategyView {
	// Идентификатор стратегии
	uint32 strategy_id = 1;
	// Автор
	string creator_id = 2;
	// Наименование стратегии
	string name = 3;
	// Признак глобальной стратегии
	bool global = 4;
	// Приоритет (актуально только для глобальной стратегии)
	uint32 priority = 5;
	// Список привязок к стратегии
	repeated StrategyBinding binds = 6;
	// Произвольное описание стратегии
	string description = 7;
	// Когда стратегия была создана
	int64 created_at = 8;
	// Когда стратегия была в последний раз обновлена
	int64 updated_at = 9;
	// Тип доставки
	DeliveryType delivery_type = 10;
}

message StrategyViewLight {
	// Идентификатор стратегии
	uint32 strategy_id = 1;
	// Автор
	string creator_id = 2;
	// Наименование стратегии
	string name = 3;
	// Признак глобальной стратегии
	bool global = 4;
	// Приоритет (актуально только для глобальной стратегии)
	uint32 priority = 5;
	// Список идентификаторов магазинов, привязанных к стратегии
	repeated string stores = 6;
	// Произвольное описание стратегии
	string description = 7;
	// Когда стратегия была создана
	int64 created_at = 8;
	// Когда стратегия была в последний раз обновлена
	int64 updated_at = 9;
	// Тип доставки
	DeliveryType delivery_type = 10;
}


message UnbindStrategyRequest {
	// Идентификатор стратегии
	uint32 strategy_id = 1;
	// Список привязок к стратегии, которые необходимо удалить
	repeated StrategyBinding binds = 2;
}

message UnbindStrategyResponse {
	// Представление стратегии
	StrategyView strategy = 1;
}


message GetStrategiesRequest {
	// Название стратегии, допускается минимум 3 символа
	string strategy_name = 1;
	// Тип доставки
	DeliveryType delivery_type = 2;
	// Список идентификаторов магазинов
	repeated string stores = 3;
}

message GetStrategiesResponse {
	// Представление стратегии
	repeated StrategyViewLight strategies = 1;
}

message GetStrategyRequest {
	// Идентификатор стратегии
	uint32 strategy_id = 1;
}

message GetStrategyResponse {
	// Представление стратегии
	StrategyView strategy = 1;
	// Смотри RuleView в контракте ниже
	repeated RuleView rules = 2;
	// Список правил для суммы минимальной корзины
	repeated MinCartRuleView min_cart_rules = 3;
}

message RuleView {
	// Идентификатор
	uint32 id = 1;
	// Идентификатор скрипта
	uint32 script_id = 2;
	// Имя скрипта
	string script_name = 3;
	// Значения параметров скрипта
	string script_param_values = 4;
	// Условия
	repeated ConditionView conditions = 5;
	// Приоритет
	int32 priority = 6;
	// Автор
	string creator_id = 7;
	// Время создания(timestamp)
	int64 created_at = 8;
}
message MinCartRuleView {
	// Идентификатор
	uint32 id = 1;
	// Значения параметров скрипта
	uint64 min_cart_value = 2;
	// Условия
	repeated ConditionView conditions = 3;
	// Приоритет
	int32 priority = 4;
	// Автор
	string creator_id = 5;
	// Время создания(timestamp)
	int64 created_at = 6;
}


message ConditionView {
	// Тип условия
	ConditionType condition_type = 1;
	// Параметры
	string params = 2;
}

message GetStrategiesForStoreRequest {
	// Идентификатор магазина
	string store_id = 1;
	// Идентификатор тенанта
	string tenant = 2;
	// Тип доставки
	DeliveryType delivery_type = 3;
}

message ExplainedStrategyView {
	// Идентификатор стратегии
	uint32 strategy_id = 1;
	// Привязка стратегии
	StrategyBinding binding = 2;
}

message GetStrategiesForStoreResponse {
	// Стратегия с привязкой
	repeated ExplainedStrategyView strategy = 1;
}

message DeleteStrategyRequest {
	// Идентификатор стратегии
	uint32 strategy_id = 1;
}

message DeleteStrategyResponse{}

// результат проверки скрипта
enum ScriptState {
	SCRIPT_VALID = 0;
	SCRIPT_ERROR = 1;
}

message CreateScriptRequest {
	// Имя скрипта
	string script_name = 1;
	// Тело скрипта
	string script_body = 2;
	// Автор
	string creator_id = 3;
}

message CreateScriptResponse {
	// Идентификатор скрипта
	uint32 script_id = 1;
	// результат проверки скрипта
	ScriptState state = 2;
	// сообщение о ошибке
	string result_message = 3;
}

message UpdateScriptRequest {
	// Идентификатор скрипта
	uint32 script_id = 1;
	// Имя скрипта
	string script_name = 2;
	// Тело скрипта
	string script_body = 3;
	// Автор
	string creator_id = 4;
}

message UpdateScriptResponse {
	ScriptState state = 1;
	string result_message = 3;
}

message GetScriptsRequest {}

message GetScriptsResponse {
	// Список скриптов
	repeated ScriptView scripts = 1;
}

message ScriptView {
	enum ScriptState {
		NONE = 0;
		TEST_OK = 1;
		TEST_FAILED = 2;
	}
	// Идентификатор скрипта
	uint32 script_id = 1;
	// Имя скрипта
	string script_name = 2;
	// Тело скрипта
	string script_body = 3;
	// Список параметров скрипта
	repeated ScriptParam required_params = 4;
	// Время создания(timestamp)
	int64 created_at = 5;
	// Время обновления(timestamp)
	int64 updated_at = 6;
	// Состояние скрипта
	ScriptState state = 7;
}

message ScriptParam {
	enum ScriptParamType {
		PARAM_FLOAT = 0;
		PARAM_INT = 1;
		PARAM_STRING = 2;
	}
	// Тип параметра
	ScriptParamType type = 1;
	// Имя параметра
	string name = 2;
	// Подпись
	string caption = 3;
	// Отношение единиц, в которых значение отображается клиенту, к единицам, в которых нам передаётся значение.
	// Например, если в подписи указано "в рублях" и в админке поле ввода в рублях, то мы хотим получать копейки,
	// а Fraction будет равен 100 (столько, сколько копеек в рублях).
	uint64 fraction = 4;
}

message GetScriptRequest {
	// Идентификатор скрипта
	uint32 script_id = 1;
}

message GetScriptResponse {
	// Список скриптов
	ScriptView script = 1;
}

message DeleteScriptRequest {
	// Идентификатор скрипта
	uint32 script_id = 1;
}
message DeleteScriptResponse {}

message GetScriptTestResultsRequest {
	// Идентификатор скрипта
	uint32 script_id = 1;
}

message GetScriptTestResultsResponse {
	// Список результатов теста скрипта
	repeated ScriptTestResult results = 1;
	// Все тесты прошли ? true - да, false - нет
	bool all_passed = 2;
}

message ScriptTestResult {
	// Имя теста
	string test_name = 1;
	// Тест пройден? true - да, false - нет
	bool passed = 2;
	// текст ошибки
	string error_message = 3;
}

message GetDeliveryPriceRequest {
	// Идентификатор заказа
	string order_id = 1;
	// Список отгрузок
	repeated Shipment shipments = 3;
	// Клиент
	Customer customer = 4;

	// Это B2B ? true - да, false - нет
	bool is_b2b_order = 5;
	// Наличие промокода ? true - да, false - нет
	bool is_promocode = 6;

	// Метод оплаты
	string payment_method = 7;
	// Наличие метода оплаты ? true - да, false - нет
	bool has_payment_method = 8;

	// Тип доставки
	DeliveryType delivery_type = 9;
	// Идентификатор тенанта
	string tenant_id = 11;

	// Название и версия платформы
	string platform_name = 12;
	string platform_version = 13;

	// Это поле используется только в тестовых запросах (например, для НТ).
	// В нем хранится некоторая тестовая метаинформация
	optional string test_meta = 14;

	// Идентификатор внешней витрины
	string client_id = 15;
}

message Shipment {
	// Идентификатор отгрузки
	string id = 1;
	// Это onDemand ? true - да, false - нет
	bool is_ondemand = 2;
	// Список продуктов
	repeated ProductRequest products = 3 [deprecated = true];
	// Вес
	uint64 weight = 4;
	// Кол-во штук товаров (сумма quantity у всех products)
	uint32 items_count = 5;
	// Цена в копейках
	uint64 price = 6;
	// Идентификатор магазина
	string store_id = 7;
	// Статус
	string status = 8;
	// Регион
	uint64 region_id = 9;
	// Наценка слота доставки в копейках
	uint64 surge_delivery_window_addition = 10;
	// координаты магазина
	float lat = 11;
	float lon = 12;
	// Идентификатор ритейлера
	uint64 retailer_id = 13;
	// Индетификаторы лейблов магазина связанные только с тенантом sbermarket
	repeated uint64 store_labels_id = 14;
	// Кол-во позиций (уникальное кол-во товаров в shipment-e)
	// По сути это количество products
	uint32 positions_count = 15;
}

message ProductRequest {
	// Количество
	uint32 quantity = 1;

	// Идентификатор продукта
	string id = 2;
	// Цена
	uint64 price = 3;
	// Цена со скидкой
	uint64 discount_price = 4;
	// Вес
	uint64 weight = 5;
}

message Customer {
	// Идентификатор клиента
	string id = 1;
	// Анонимный идентификатор
	string anonymous_id = 2;
	// Кол-во заказов
	uint32 orders_count = 3;
	// Время регистрации (timestamp)
	int64 registered_at = 4;
	// Координаты клиента
	float lat = 5;
	float lon = 6;
}

message GetDeliveryPriceResponse {
	// Возможен ли заказ ? true - да, false - нет
	bool is_order_possible = 1;
	// Минимальная цена корзины
	uint64 minimal_cart_price = 2 [deprecated = true];
	// Минимальное кол-во позиций в корзине
	uint32 minimal_cart_items = 3 [deprecated = true];

	// Итоговая цена отгрузки в копейках
	uint64 total_shipping_price = 4;
	// Список отгрузок
	repeated PricedShipment shipments = 5;
}

message PricedShipment {
	// Идентификатор отгрузки
	string shipment_id = 1;
	// Цена отгрузки в копейках
	uint64 shipping_price = 2;
	// Timestamp момента времени, когда оффер перестаёт быть действительным
	int64 offer_expires_at = 3;
	// Хеш применённого оффера для аналитики
	string offer_hash = 4;
	// Ценовая лесенка
	repeated LadderStep ladder = 5;
	// Идентификатор стратегии, примененной при расчете цены
	uint32 strategy_id = 6;
	// Идентификатор правила, примененного при расчете цены
	uint32 rule_id = 7;
	// true, если цена была определена существующим offer'ом. false, если цена свежепосчитанная
	bool we_had_offer = 8;
	// Надбавка к цене при высоком спросе в копейках
	uint64 surge_level_addition = 9;
	// флаг что использовалась надбавка к цене
	bool surge_used = 10;
	// Уровень от сервиса surgelevel
	float surge_level = 11;
	// Примененная наценка слота в копейках
	uint64 surge_delivery_window_addition = 12;
	// Подсказки о том, что может повлиять на цену. Например, сколько составляет надбавка за вес.
	repeated PriceHint hints = 13;
	// Объяснение того почему цена именно такая
	PriceExplanation price_explanation = 14;
	// Минимальная цена корзины (уже с учетом сурджа)
	uint64 minimal_cart_price = 15;
	// Наценка из-за сурджа для мин корзины в копейках, которая будет прибавлена к изначальной мин корзине
	uint64 surge_min_cart_addition = 16;
	// Идентификатор правила, по которому рассчитана мин корзина
	uint32 min_cart_rule_id = 17;
}

message PriceHint {
	// Например, overweight. Неспецифицирован, нужен исключительно для подсказки фронту о чём идёт речь.
	string type = 1;
	// Строчка, которую нужно отобразить. Например, "+10 кг"
	string caption = 2;
	// Цена, которую нужно отобразить пользователю, в копейках
	uint64 price = 3;
	// Дополнительная строчка, касающаяся подсказки. Например, "Свыше 30кг"
	string additional_label = 4;
	// Опциональная строчка с json'ом, который может быть заполнен скриптом.
	// Служит для передачи фронту каких-то неформатных данных, сверх того что предоставляют caption/additional_label
	string meta = 5;
}

message PriceExplanation {
	// Условия, которые было необходимо пройти, чтобы цена оказалась именно такой
	repeated PricePassedCondition passed_conditions = 1;
	// Компоненты, из которых состоит цена. Сумма цен в компонентах не обязательно равна цене доставки.
	repeated PriceComponent price_components = 2;
}

message PricePassedCondition {
	// Какое условие нужно было пройти, чтобы применилась данная цена?
	string type = 1;
	// Параметры для условия
	string params = 2;
}

// Компонент, из которого состоит цена
message PriceComponent {
	// Тип компонента. Аналогичен таковым у PriceHint, например "overweight"
	string type = 1;
	// Сколько денег добавил в цену этот компонент
	uint64 price = 2;
	// Дополнительная информация о компоненте, в формате json
	string meta = 3;
}

message LadderStep {
	// Ценовой интервал
	optional uint64 price_from = 1; // null означает "от нуля"
	optional uint64 price_to = 2; // null означает "до бесконечности"
	// Цена отгрузки
	uint64 shipping_price = 3;
	// Компоненты цены отгрузки
	repeated PriceComponent price_components = 4;
}

message GetMinCartAmountsRequest {
	repeated Store stores = 1;
	Customer customer = 2;
	string tenant = 3;
	DeliveryType delivery_type = 4;
	// Название и версия платформы
	string platform_name = 5;
	string platform_version = 6;
}

message Store {
	// Идентификатор магазина
	string id = 1;
	// Координаты магазина
	float lat = 2;
	float lon = 3;
	// Это onDemand ? true - да, false - нет
	bool is_ondemand = 7;
	// Регион
	uint64 region_id = 8;
	// Идентификатор ритейлера
	uint64 retailer_id = 9;
}

// Минимальная стоимость корзины для магазина
message GetMinCartAmountsResponse {
	// Если мин. корзину не удалось посчитать для магазина и нужно юзать коллбек,
	// то данных по этому магазину не будет в списке
	repeated MinCartAmount min_cart_amounts = 1;
}

message MinCartAmount {
	string store_id = 1;
	uint64 amount = 2 [deprecated = true];
	uint64 amount_courier_delivery = 3;
	uint64 amount_self_delivery = 4;
}

message GetDeliveryConditionsRequest {
	repeated Store stores = 1;
	Customer customer = 2;
	string tenant = 3;
	DeliveryType delivery_type = 4;
	// Название и версия платформы
	string platform_name = 5;
	string platform_version = 6;
}

message Surge {
	// Флаг сурджа
	bool is_on = 1;
	// Уровень сурджа
	float level = 2;
	// Остаточный TTL для текущего сурджа
	int64 ttl = 3;
}

message DeliveryCondition {
	// Идентификатор магазина
	string store_id = 1;
	// Минимальная цена корзины
	uint64 min_cart_amount = 2;
	// Состояние сурджа
	Surge surge = 3;
	// Лесенка цен доставки
	repeated LadderStep ladder = 4;
}

message GetDeliveryConditionsResponse {
	// Условия доставки
	repeated DeliveryCondition delivery_conditions = 1;
}

message CreateBindingRuleRequest {
	// Идентификатор стратегии, к которой будет осуществляться привязка
	uint32 strategy_id = 1;
	// Идентификатор тенанта
	optional string tenant_id = 2;
	// Идентификатор региона
	optional uint64 region_id = 3;
	// Идентификатор ритейлера
	optional uint64 retailer_id = 4;
	// Будет ли привязка осуществляться только для быстрой доставки
	optional bool ondemand = 5;
	// Идентификатор лейбла
	optional uint64 label_id = 6;
	// Описание правила
	optional string description = 7;
}

message CreateBindingRuleResponse {}

message UpdateBindingRuleRequest {
	// Идентификатор правила, которое подлежит обновлению
	uint32 binding_rule_id = 1;
	// Замечание: в контексте этого запроса все опциональные поля с пустым значением
	// рассматриваются как не подлежащие обновлению
	//
	// Идентификатор стратегии
	optional uint32 strategy_id = 2;
	// Идентификатор тенанта
	optional string tenant_id = 3;
	// Идентификатор региона
	optional uint64 region_id = 4;
	// Идентификатор ритейлера
	optional uint64 retailer_id = 5;
	// Признак быстрой доставки
	optional bool ondemand = 6;
	// Идентификатор лейбла
	optional uint64 label_id = 7;
	// Описание правила
	optional string description = 8;
}

message UpdateBindingRuleResponse {}

message GetBindingRulesRequest {}

message GetBindingRulesResponse {
	// Массив всех правил привязки
	repeated BindingRule binding_rules = 1;
}

message DeleteBindingRuleRequest {
	// Идентификатор правила, подлежащего удалению
	uint32 binding_rule_id = 1;
}

message DeleteBindingRuleResponse {}

message BindingRule {
	// Идентификатор правила
	uint32 id = 1;
	// Идентификатор стратегии
	uint32 strategy_id = 2;
	// Способ доставки (берется из соответствующего поля стратегии)
	DeliveryType shipping = 3;
	// Идентификатор тенанта
	optional string tenant_id = 4;
	// Идентификатор региона
	optional uint64 region_id = 5;
	// Идентификатор ритейлера
	optional uint64 retailer_id = 6;
	// Признак быстрой доставки
	optional bool ondemand = 7;
	// Идентификатор лейбла
	optional uint64 label_id = 8;
	// Время создания правила
	google.protobuf.Timestamp created_at = 9;
	// Время последнего обновления правила
	google.protobuf.Timestamp updated_at = 10;
	// Время удаления правила (актуально только для удаленных правил)
	optional google.protobuf.Timestamp deleted_at = 11;
	// Описание правила
	optional string description = 12;
}

// Один интервал для surge
message SurgeInterval {
	// Левая граница интервала, не входит в диапазон
	float left_boundary = 1;
	// Правая граница интервала, входит в диапазон
	float right_boundary = 2;
	// Дополнительная наценка, напрямую добавленная к цене доставки
	uint64 price_addition = 3;
	// Дополнительная наценка, добавленный процент от цены доставки
	uint64 percent_addition = 4;
	// Дополнительная наценка, напрямую добавленная к мин корзине
	uint64 min_cart_addition = 5;
}

// Ожидаемый тип данных для surge switchback-теста
enum SurgeSwitchbackDataType {
	CSV = 0;
}

// Описание одного surge switchback теста
message SurgeSwitchback {
	// Дата и время начала срабатывания эксперимента, входит в диапазон
	google.protobuf.Timestamp start_date_time = 1;
	// Дата и время окончания срабатывания эксперимента, не входит в диапазон
	google.protobuf.Timestamp end_date_time = 2;
	// Идентификатор региона, в котором должен срабатывать эксперимент
	int64 region_id = 3;
	// Идентификатор вертикали
	int32 vertical = 4;
	// Метка группы эксперимента
	string group = 5;
	// Параметры эксперимента, json-строка
	string parameters = 6;
}

message SetSwitchbacksRequest {
	string data = 1;
	SurgeSwitchbackDataType type = 2;
}

message SetSwitchbacksResponse {

}

message GetSwitchbacksRequest {

}

message GetSwitchbacksResponse {
	repeated SurgeSwitchback experiments = 1;
}

message SurgeParameters {
	message Parameters {
		repeated SurgeInterval intervals = 1;
	};

	uint64 id = 1;
	int64 region_id = 2;
	int32 vertical = 3;
	Parameters parameters = 4;
};

message GetSurgeParametersRequest {};

message GetSurgeParametersResponse {
	repeated SurgeParameters parameters = 1;
};

message SetSurgeParametersRequest {
	repeated SurgeParameters parameters = 1;
};

message SetSurgeParametersResponse {};

message DeleteSurgeParametersRequest {
	repeated uint64 id = 1;
};

message DeleteSurgeParametersResponse {};
