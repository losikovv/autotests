// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: on_demand/import_planning_periods.proto

package shifts;

public final class ImportPlanningPeriods {
  private ImportPlanningPeriods() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }

  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
    registerAllExtensions(
        (com.google.protobuf.ExtensionRegistryLite) registry);
  }
  public interface PlaningPeriodsImportOrBuilder extends
      // @@protoc_insertion_point(interface_extends:shifts.PlaningPeriodsImport)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Идентификатор импорта, чтобы избегать заливки дублированных
     * данных по техническим причинам
     * </pre>
     *
     * <code>string id = 1;</code>
     * @return The id.
     */
    java.lang.String getId();
    /**
     * <pre>
     * Идентификатор импорта, чтобы избегать заливки дублированных
     * данных по техническим причинам
     * </pre>
     *
     * <code>string id = 1;</code>
     * @return The bytes for id.
     */
    com.google.protobuf.ByteString
        getIdBytes();

    /**
     * <pre>
     * Дата и время импорта. Формат значения RFC 3339
     * Пример данных: 2021-05-01T19:00:00+03:00
     * </pre>
     *
     * <code>string sent_at = 2;</code>
     * @return The sentAt.
     */
    java.lang.String getSentAt();
    /**
     * <pre>
     * Дата и время импорта. Формат значения RFC 3339
     * Пример данных: 2021-05-01T19:00:00+03:00
     * </pre>
     *
     * <code>string sent_at = 2;</code>
     * @return The bytes for sentAt.
     */
    com.google.protobuf.ByteString
        getSentAtBytes();

    /**
     * <pre>
     * Массив объектов с импортируемыми плановыми периодами
     * </pre>
     *
     * <code>repeated .shifts.PlanningPeriodItem planning_periods = 3;</code>
     */
    java.util.List<shifts.ImportPlanningPeriods.PlanningPeriodItem> 
        getPlanningPeriodsList();
    /**
     * <pre>
     * Массив объектов с импортируемыми плановыми периодами
     * </pre>
     *
     * <code>repeated .shifts.PlanningPeriodItem planning_periods = 3;</code>
     */
    shifts.ImportPlanningPeriods.PlanningPeriodItem getPlanningPeriods(int index);
    /**
     * <pre>
     * Массив объектов с импортируемыми плановыми периодами
     * </pre>
     *
     * <code>repeated .shifts.PlanningPeriodItem planning_periods = 3;</code>
     */
    int getPlanningPeriodsCount();
    /**
     * <pre>
     * Массив объектов с импортируемыми плановыми периодами
     * </pre>
     *
     * <code>repeated .shifts.PlanningPeriodItem planning_periods = 3;</code>
     */
    java.util.List<? extends shifts.ImportPlanningPeriods.PlanningPeriodItemOrBuilder> 
        getPlanningPeriodsOrBuilderList();
    /**
     * <pre>
     * Массив объектов с импортируемыми плановыми периодами
     * </pre>
     *
     * <code>repeated .shifts.PlanningPeriodItem planning_periods = 3;</code>
     */
    shifts.ImportPlanningPeriods.PlanningPeriodItemOrBuilder getPlanningPeriodsOrBuilder(
        int index);
  }
  /**
   * Protobuf type {@code shifts.PlaningPeriodsImport}
   */
  public static final class PlaningPeriodsImport extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:shifts.PlaningPeriodsImport)
      PlaningPeriodsImportOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use PlaningPeriodsImport.newBuilder() to construct.
    private PlaningPeriodsImport(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private PlaningPeriodsImport() {
      id_ = "";
      sentAt_ = "";
      planningPeriods_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new PlaningPeriodsImport();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private PlaningPeriodsImport(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              java.lang.String s = input.readStringRequireUtf8();

              id_ = s;
              break;
            }
            case 18: {
              java.lang.String s = input.readStringRequireUtf8();

              sentAt_ = s;
              break;
            }
            case 26: {
              if (!((mutable_bitField0_ & 0x00000001) != 0)) {
                planningPeriods_ = new java.util.ArrayList<shifts.ImportPlanningPeriods.PlanningPeriodItem>();
                mutable_bitField0_ |= 0x00000001;
              }
              planningPeriods_.add(
                  input.readMessage(shifts.ImportPlanningPeriods.PlanningPeriodItem.parser(), extensionRegistry));
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000001) != 0)) {
          planningPeriods_ = java.util.Collections.unmodifiableList(planningPeriods_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return shifts.ImportPlanningPeriods.internal_static_shifts_PlaningPeriodsImport_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return shifts.ImportPlanningPeriods.internal_static_shifts_PlaningPeriodsImport_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              shifts.ImportPlanningPeriods.PlaningPeriodsImport.class, shifts.ImportPlanningPeriods.PlaningPeriodsImport.Builder.class);
    }

    public static final int ID_FIELD_NUMBER = 1;
    private volatile java.lang.Object id_;
    /**
     * <pre>
     * Идентификатор импорта, чтобы избегать заливки дублированных
     * данных по техническим причинам
     * </pre>
     *
     * <code>string id = 1;</code>
     * @return The id.
     */
    @java.lang.Override
    public java.lang.String getId() {
      java.lang.Object ref = id_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        id_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Идентификатор импорта, чтобы избегать заливки дублированных
     * данных по техническим причинам
     * </pre>
     *
     * <code>string id = 1;</code>
     * @return The bytes for id.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getIdBytes() {
      java.lang.Object ref = id_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        id_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int SENT_AT_FIELD_NUMBER = 2;
    private volatile java.lang.Object sentAt_;
    /**
     * <pre>
     * Дата и время импорта. Формат значения RFC 3339
     * Пример данных: 2021-05-01T19:00:00+03:00
     * </pre>
     *
     * <code>string sent_at = 2;</code>
     * @return The sentAt.
     */
    @java.lang.Override
    public java.lang.String getSentAt() {
      java.lang.Object ref = sentAt_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        sentAt_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Дата и время импорта. Формат значения RFC 3339
     * Пример данных: 2021-05-01T19:00:00+03:00
     * </pre>
     *
     * <code>string sent_at = 2;</code>
     * @return The bytes for sentAt.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getSentAtBytes() {
      java.lang.Object ref = sentAt_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        sentAt_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int PLANNING_PERIODS_FIELD_NUMBER = 3;
    private java.util.List<shifts.ImportPlanningPeriods.PlanningPeriodItem> planningPeriods_;
    /**
     * <pre>
     * Массив объектов с импортируемыми плановыми периодами
     * </pre>
     *
     * <code>repeated .shifts.PlanningPeriodItem planning_periods = 3;</code>
     */
    @java.lang.Override
    public java.util.List<shifts.ImportPlanningPeriods.PlanningPeriodItem> getPlanningPeriodsList() {
      return planningPeriods_;
    }
    /**
     * <pre>
     * Массив объектов с импортируемыми плановыми периодами
     * </pre>
     *
     * <code>repeated .shifts.PlanningPeriodItem planning_periods = 3;</code>
     */
    @java.lang.Override
    public java.util.List<? extends shifts.ImportPlanningPeriods.PlanningPeriodItemOrBuilder> 
        getPlanningPeriodsOrBuilderList() {
      return planningPeriods_;
    }
    /**
     * <pre>
     * Массив объектов с импортируемыми плановыми периодами
     * </pre>
     *
     * <code>repeated .shifts.PlanningPeriodItem planning_periods = 3;</code>
     */
    @java.lang.Override
    public int getPlanningPeriodsCount() {
      return planningPeriods_.size();
    }
    /**
     * <pre>
     * Массив объектов с импортируемыми плановыми периодами
     * </pre>
     *
     * <code>repeated .shifts.PlanningPeriodItem planning_periods = 3;</code>
     */
    @java.lang.Override
    public shifts.ImportPlanningPeriods.PlanningPeriodItem getPlanningPeriods(int index) {
      return planningPeriods_.get(index);
    }
    /**
     * <pre>
     * Массив объектов с импортируемыми плановыми периодами
     * </pre>
     *
     * <code>repeated .shifts.PlanningPeriodItem planning_periods = 3;</code>
     */
    @java.lang.Override
    public shifts.ImportPlanningPeriods.PlanningPeriodItemOrBuilder getPlanningPeriodsOrBuilder(
        int index) {
      return planningPeriods_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!getIdBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, id_);
      }
      if (!getSentAtBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, sentAt_);
      }
      for (int i = 0; i < planningPeriods_.size(); i++) {
        output.writeMessage(3, planningPeriods_.get(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!getIdBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, id_);
      }
      if (!getSentAtBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, sentAt_);
      }
      for (int i = 0; i < planningPeriods_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, planningPeriods_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof shifts.ImportPlanningPeriods.PlaningPeriodsImport)) {
        return super.equals(obj);
      }
      shifts.ImportPlanningPeriods.PlaningPeriodsImport other = (shifts.ImportPlanningPeriods.PlaningPeriodsImport) obj;

      if (!getId()
          .equals(other.getId())) return false;
      if (!getSentAt()
          .equals(other.getSentAt())) return false;
      if (!getPlanningPeriodsList()
          .equals(other.getPlanningPeriodsList())) return false;
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + ID_FIELD_NUMBER;
      hash = (53 * hash) + getId().hashCode();
      hash = (37 * hash) + SENT_AT_FIELD_NUMBER;
      hash = (53 * hash) + getSentAt().hashCode();
      if (getPlanningPeriodsCount() > 0) {
        hash = (37 * hash) + PLANNING_PERIODS_FIELD_NUMBER;
        hash = (53 * hash) + getPlanningPeriodsList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static shifts.ImportPlanningPeriods.PlaningPeriodsImport parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static shifts.ImportPlanningPeriods.PlaningPeriodsImport parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static shifts.ImportPlanningPeriods.PlaningPeriodsImport parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static shifts.ImportPlanningPeriods.PlaningPeriodsImport parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static shifts.ImportPlanningPeriods.PlaningPeriodsImport parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static shifts.ImportPlanningPeriods.PlaningPeriodsImport parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static shifts.ImportPlanningPeriods.PlaningPeriodsImport parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static shifts.ImportPlanningPeriods.PlaningPeriodsImport parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static shifts.ImportPlanningPeriods.PlaningPeriodsImport parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static shifts.ImportPlanningPeriods.PlaningPeriodsImport parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static shifts.ImportPlanningPeriods.PlaningPeriodsImport parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static shifts.ImportPlanningPeriods.PlaningPeriodsImport parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(shifts.ImportPlanningPeriods.PlaningPeriodsImport prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code shifts.PlaningPeriodsImport}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:shifts.PlaningPeriodsImport)
        shifts.ImportPlanningPeriods.PlaningPeriodsImportOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return shifts.ImportPlanningPeriods.internal_static_shifts_PlaningPeriodsImport_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return shifts.ImportPlanningPeriods.internal_static_shifts_PlaningPeriodsImport_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                shifts.ImportPlanningPeriods.PlaningPeriodsImport.class, shifts.ImportPlanningPeriods.PlaningPeriodsImport.Builder.class);
      }

      // Construct using shifts.ImportPlanningPeriods.PlaningPeriodsImport.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getPlanningPeriodsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        id_ = "";

        sentAt_ = "";

        if (planningPeriodsBuilder_ == null) {
          planningPeriods_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
        } else {
          planningPeriodsBuilder_.clear();
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return shifts.ImportPlanningPeriods.internal_static_shifts_PlaningPeriodsImport_descriptor;
      }

      @java.lang.Override
      public shifts.ImportPlanningPeriods.PlaningPeriodsImport getDefaultInstanceForType() {
        return shifts.ImportPlanningPeriods.PlaningPeriodsImport.getDefaultInstance();
      }

      @java.lang.Override
      public shifts.ImportPlanningPeriods.PlaningPeriodsImport build() {
        shifts.ImportPlanningPeriods.PlaningPeriodsImport result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public shifts.ImportPlanningPeriods.PlaningPeriodsImport buildPartial() {
        shifts.ImportPlanningPeriods.PlaningPeriodsImport result = new shifts.ImportPlanningPeriods.PlaningPeriodsImport(this);
        int from_bitField0_ = bitField0_;
        result.id_ = id_;
        result.sentAt_ = sentAt_;
        if (planningPeriodsBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0)) {
            planningPeriods_ = java.util.Collections.unmodifiableList(planningPeriods_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.planningPeriods_ = planningPeriods_;
        } else {
          result.planningPeriods_ = planningPeriodsBuilder_.build();
        }
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof shifts.ImportPlanningPeriods.PlaningPeriodsImport) {
          return mergeFrom((shifts.ImportPlanningPeriods.PlaningPeriodsImport)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(shifts.ImportPlanningPeriods.PlaningPeriodsImport other) {
        if (other == shifts.ImportPlanningPeriods.PlaningPeriodsImport.getDefaultInstance()) return this;
        if (!other.getId().isEmpty()) {
          id_ = other.id_;
          onChanged();
        }
        if (!other.getSentAt().isEmpty()) {
          sentAt_ = other.sentAt_;
          onChanged();
        }
        if (planningPeriodsBuilder_ == null) {
          if (!other.planningPeriods_.isEmpty()) {
            if (planningPeriods_.isEmpty()) {
              planningPeriods_ = other.planningPeriods_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensurePlanningPeriodsIsMutable();
              planningPeriods_.addAll(other.planningPeriods_);
            }
            onChanged();
          }
        } else {
          if (!other.planningPeriods_.isEmpty()) {
            if (planningPeriodsBuilder_.isEmpty()) {
              planningPeriodsBuilder_.dispose();
              planningPeriodsBuilder_ = null;
              planningPeriods_ = other.planningPeriods_;
              bitField0_ = (bitField0_ & ~0x00000001);
              planningPeriodsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getPlanningPeriodsFieldBuilder() : null;
            } else {
              planningPeriodsBuilder_.addAllMessages(other.planningPeriods_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        shifts.ImportPlanningPeriods.PlaningPeriodsImport parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (shifts.ImportPlanningPeriods.PlaningPeriodsImport) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object id_ = "";
      /**
       * <pre>
       * Идентификатор импорта, чтобы избегать заливки дублированных
       * данных по техническим причинам
       * </pre>
       *
       * <code>string id = 1;</code>
       * @return The id.
       */
      public java.lang.String getId() {
        java.lang.Object ref = id_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          id_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Идентификатор импорта, чтобы избегать заливки дублированных
       * данных по техническим причинам
       * </pre>
       *
       * <code>string id = 1;</code>
       * @return The bytes for id.
       */
      public com.google.protobuf.ByteString
          getIdBytes() {
        java.lang.Object ref = id_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          id_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Идентификатор импорта, чтобы избегать заливки дублированных
       * данных по техническим причинам
       * </pre>
       *
       * <code>string id = 1;</code>
       * @param value The id to set.
       * @return This builder for chaining.
       */
      public Builder setId(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        id_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Идентификатор импорта, чтобы избегать заливки дублированных
       * данных по техническим причинам
       * </pre>
       *
       * <code>string id = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearId() {
        
        id_ = getDefaultInstance().getId();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Идентификатор импорта, чтобы избегать заливки дублированных
       * данных по техническим причинам
       * </pre>
       *
       * <code>string id = 1;</code>
       * @param value The bytes for id to set.
       * @return This builder for chaining.
       */
      public Builder setIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        id_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object sentAt_ = "";
      /**
       * <pre>
       * Дата и время импорта. Формат значения RFC 3339
       * Пример данных: 2021-05-01T19:00:00+03:00
       * </pre>
       *
       * <code>string sent_at = 2;</code>
       * @return The sentAt.
       */
      public java.lang.String getSentAt() {
        java.lang.Object ref = sentAt_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          sentAt_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Дата и время импорта. Формат значения RFC 3339
       * Пример данных: 2021-05-01T19:00:00+03:00
       * </pre>
       *
       * <code>string sent_at = 2;</code>
       * @return The bytes for sentAt.
       */
      public com.google.protobuf.ByteString
          getSentAtBytes() {
        java.lang.Object ref = sentAt_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          sentAt_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Дата и время импорта. Формат значения RFC 3339
       * Пример данных: 2021-05-01T19:00:00+03:00
       * </pre>
       *
       * <code>string sent_at = 2;</code>
       * @param value The sentAt to set.
       * @return This builder for chaining.
       */
      public Builder setSentAt(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        sentAt_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Дата и время импорта. Формат значения RFC 3339
       * Пример данных: 2021-05-01T19:00:00+03:00
       * </pre>
       *
       * <code>string sent_at = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearSentAt() {
        
        sentAt_ = getDefaultInstance().getSentAt();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Дата и время импорта. Формат значения RFC 3339
       * Пример данных: 2021-05-01T19:00:00+03:00
       * </pre>
       *
       * <code>string sent_at = 2;</code>
       * @param value The bytes for sentAt to set.
       * @return This builder for chaining.
       */
      public Builder setSentAtBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        sentAt_ = value;
        onChanged();
        return this;
      }

      private java.util.List<shifts.ImportPlanningPeriods.PlanningPeriodItem> planningPeriods_ =
        java.util.Collections.emptyList();
      private void ensurePlanningPeriodsIsMutable() {
        if (!((bitField0_ & 0x00000001) != 0)) {
          planningPeriods_ = new java.util.ArrayList<shifts.ImportPlanningPeriods.PlanningPeriodItem>(planningPeriods_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          shifts.ImportPlanningPeriods.PlanningPeriodItem, shifts.ImportPlanningPeriods.PlanningPeriodItem.Builder, shifts.ImportPlanningPeriods.PlanningPeriodItemOrBuilder> planningPeriodsBuilder_;

      /**
       * <pre>
       * Массив объектов с импортируемыми плановыми периодами
       * </pre>
       *
       * <code>repeated .shifts.PlanningPeriodItem planning_periods = 3;</code>
       */
      public java.util.List<shifts.ImportPlanningPeriods.PlanningPeriodItem> getPlanningPeriodsList() {
        if (planningPeriodsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(planningPeriods_);
        } else {
          return planningPeriodsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Массив объектов с импортируемыми плановыми периодами
       * </pre>
       *
       * <code>repeated .shifts.PlanningPeriodItem planning_periods = 3;</code>
       */
      public int getPlanningPeriodsCount() {
        if (planningPeriodsBuilder_ == null) {
          return planningPeriods_.size();
        } else {
          return planningPeriodsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Массив объектов с импортируемыми плановыми периодами
       * </pre>
       *
       * <code>repeated .shifts.PlanningPeriodItem planning_periods = 3;</code>
       */
      public shifts.ImportPlanningPeriods.PlanningPeriodItem getPlanningPeriods(int index) {
        if (planningPeriodsBuilder_ == null) {
          return planningPeriods_.get(index);
        } else {
          return planningPeriodsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Массив объектов с импортируемыми плановыми периодами
       * </pre>
       *
       * <code>repeated .shifts.PlanningPeriodItem planning_periods = 3;</code>
       */
      public Builder setPlanningPeriods(
          int index, shifts.ImportPlanningPeriods.PlanningPeriodItem value) {
        if (planningPeriodsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensurePlanningPeriodsIsMutable();
          planningPeriods_.set(index, value);
          onChanged();
        } else {
          planningPeriodsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Массив объектов с импортируемыми плановыми периодами
       * </pre>
       *
       * <code>repeated .shifts.PlanningPeriodItem planning_periods = 3;</code>
       */
      public Builder setPlanningPeriods(
          int index, shifts.ImportPlanningPeriods.PlanningPeriodItem.Builder builderForValue) {
        if (planningPeriodsBuilder_ == null) {
          ensurePlanningPeriodsIsMutable();
          planningPeriods_.set(index, builderForValue.build());
          onChanged();
        } else {
          planningPeriodsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Массив объектов с импортируемыми плановыми периодами
       * </pre>
       *
       * <code>repeated .shifts.PlanningPeriodItem planning_periods = 3;</code>
       */
      public Builder addPlanningPeriods(shifts.ImportPlanningPeriods.PlanningPeriodItem value) {
        if (planningPeriodsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensurePlanningPeriodsIsMutable();
          planningPeriods_.add(value);
          onChanged();
        } else {
          planningPeriodsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Массив объектов с импортируемыми плановыми периодами
       * </pre>
       *
       * <code>repeated .shifts.PlanningPeriodItem planning_periods = 3;</code>
       */
      public Builder addPlanningPeriods(
          int index, shifts.ImportPlanningPeriods.PlanningPeriodItem value) {
        if (planningPeriodsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensurePlanningPeriodsIsMutable();
          planningPeriods_.add(index, value);
          onChanged();
        } else {
          planningPeriodsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Массив объектов с импортируемыми плановыми периодами
       * </pre>
       *
       * <code>repeated .shifts.PlanningPeriodItem planning_periods = 3;</code>
       */
      public Builder addPlanningPeriods(
          shifts.ImportPlanningPeriods.PlanningPeriodItem.Builder builderForValue) {
        if (planningPeriodsBuilder_ == null) {
          ensurePlanningPeriodsIsMutable();
          planningPeriods_.add(builderForValue.build());
          onChanged();
        } else {
          planningPeriodsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Массив объектов с импортируемыми плановыми периодами
       * </pre>
       *
       * <code>repeated .shifts.PlanningPeriodItem planning_periods = 3;</code>
       */
      public Builder addPlanningPeriods(
          int index, shifts.ImportPlanningPeriods.PlanningPeriodItem.Builder builderForValue) {
        if (planningPeriodsBuilder_ == null) {
          ensurePlanningPeriodsIsMutable();
          planningPeriods_.add(index, builderForValue.build());
          onChanged();
        } else {
          planningPeriodsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Массив объектов с импортируемыми плановыми периодами
       * </pre>
       *
       * <code>repeated .shifts.PlanningPeriodItem planning_periods = 3;</code>
       */
      public Builder addAllPlanningPeriods(
          java.lang.Iterable<? extends shifts.ImportPlanningPeriods.PlanningPeriodItem> values) {
        if (planningPeriodsBuilder_ == null) {
          ensurePlanningPeriodsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, planningPeriods_);
          onChanged();
        } else {
          planningPeriodsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Массив объектов с импортируемыми плановыми периодами
       * </pre>
       *
       * <code>repeated .shifts.PlanningPeriodItem planning_periods = 3;</code>
       */
      public Builder clearPlanningPeriods() {
        if (planningPeriodsBuilder_ == null) {
          planningPeriods_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          planningPeriodsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Массив объектов с импортируемыми плановыми периодами
       * </pre>
       *
       * <code>repeated .shifts.PlanningPeriodItem planning_periods = 3;</code>
       */
      public Builder removePlanningPeriods(int index) {
        if (planningPeriodsBuilder_ == null) {
          ensurePlanningPeriodsIsMutable();
          planningPeriods_.remove(index);
          onChanged();
        } else {
          planningPeriodsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Массив объектов с импортируемыми плановыми периодами
       * </pre>
       *
       * <code>repeated .shifts.PlanningPeriodItem planning_periods = 3;</code>
       */
      public shifts.ImportPlanningPeriods.PlanningPeriodItem.Builder getPlanningPeriodsBuilder(
          int index) {
        return getPlanningPeriodsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Массив объектов с импортируемыми плановыми периодами
       * </pre>
       *
       * <code>repeated .shifts.PlanningPeriodItem planning_periods = 3;</code>
       */
      public shifts.ImportPlanningPeriods.PlanningPeriodItemOrBuilder getPlanningPeriodsOrBuilder(
          int index) {
        if (planningPeriodsBuilder_ == null) {
          return planningPeriods_.get(index);  } else {
          return planningPeriodsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Массив объектов с импортируемыми плановыми периодами
       * </pre>
       *
       * <code>repeated .shifts.PlanningPeriodItem planning_periods = 3;</code>
       */
      public java.util.List<? extends shifts.ImportPlanningPeriods.PlanningPeriodItemOrBuilder> 
           getPlanningPeriodsOrBuilderList() {
        if (planningPeriodsBuilder_ != null) {
          return planningPeriodsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(planningPeriods_);
        }
      }
      /**
       * <pre>
       * Массив объектов с импортируемыми плановыми периодами
       * </pre>
       *
       * <code>repeated .shifts.PlanningPeriodItem planning_periods = 3;</code>
       */
      public shifts.ImportPlanningPeriods.PlanningPeriodItem.Builder addPlanningPeriodsBuilder() {
        return getPlanningPeriodsFieldBuilder().addBuilder(
            shifts.ImportPlanningPeriods.PlanningPeriodItem.getDefaultInstance());
      }
      /**
       * <pre>
       * Массив объектов с импортируемыми плановыми периодами
       * </pre>
       *
       * <code>repeated .shifts.PlanningPeriodItem planning_periods = 3;</code>
       */
      public shifts.ImportPlanningPeriods.PlanningPeriodItem.Builder addPlanningPeriodsBuilder(
          int index) {
        return getPlanningPeriodsFieldBuilder().addBuilder(
            index, shifts.ImportPlanningPeriods.PlanningPeriodItem.getDefaultInstance());
      }
      /**
       * <pre>
       * Массив объектов с импортируемыми плановыми периодами
       * </pre>
       *
       * <code>repeated .shifts.PlanningPeriodItem planning_periods = 3;</code>
       */
      public java.util.List<shifts.ImportPlanningPeriods.PlanningPeriodItem.Builder> 
           getPlanningPeriodsBuilderList() {
        return getPlanningPeriodsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          shifts.ImportPlanningPeriods.PlanningPeriodItem, shifts.ImportPlanningPeriods.PlanningPeriodItem.Builder, shifts.ImportPlanningPeriods.PlanningPeriodItemOrBuilder> 
          getPlanningPeriodsFieldBuilder() {
        if (planningPeriodsBuilder_ == null) {
          planningPeriodsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              shifts.ImportPlanningPeriods.PlanningPeriodItem, shifts.ImportPlanningPeriods.PlanningPeriodItem.Builder, shifts.ImportPlanningPeriods.PlanningPeriodItemOrBuilder>(
                  planningPeriods_,
                  ((bitField0_ & 0x00000001) != 0),
                  getParentForChildren(),
                  isClean());
          planningPeriods_ = null;
        }
        return planningPeriodsBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:shifts.PlaningPeriodsImport)
    }

    // @@protoc_insertion_point(class_scope:shifts.PlaningPeriodsImport)
    private static final shifts.ImportPlanningPeriods.PlaningPeriodsImport DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new shifts.ImportPlanningPeriods.PlaningPeriodsImport();
    }

    public static shifts.ImportPlanningPeriods.PlaningPeriodsImport getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<PlaningPeriodsImport>
        PARSER = new com.google.protobuf.AbstractParser<PlaningPeriodsImport>() {
      @java.lang.Override
      public PlaningPeriodsImport parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new PlaningPeriodsImport(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<PlaningPeriodsImport> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<PlaningPeriodsImport> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public shifts.ImportPlanningPeriods.PlaningPeriodsImport getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface PlanningPeriodItemOrBuilder extends
      // @@protoc_insertion_point(interface_extends:shifts.PlanningPeriodItem)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Зона планирования, в которой предполагается работа партнера.
     * В данный момент зона планирования эквивалентна территории доставки.
     * </pre>
     *
     * <code>uint32 planning_area_id = 1;</code>
     * @return The planningAreaId.
     */
    int getPlanningAreaId();

    /**
     * <pre>
     * Роль партнера, для которой создается плановый период.
     * В данный момент в данном поле могут приняты следующие значения:
     * * driver - курьер
     * * shopper - сборщик
     * * universal - универсал
     * </pre>
     *
     * <code>string role = 2;</code>
     * @return The role.
     */
    java.lang.String getRole();
    /**
     * <pre>
     * Роль партнера, для которой создается плановый период.
     * В данный момент в данном поле могут приняты следующие значения:
     * * driver - курьер
     * * shopper - сборщик
     * * universal - универсал
     * </pre>
     *
     * <code>string role = 2;</code>
     * @return The bytes for role.
     */
    com.google.protobuf.ByteString
        getRoleBytes();

    /**
     * <pre>
     * Дата и время начала планового периода. Формат значения RFC 3339
     * Пример данных: 2021-05-01T19:00:00+03:00
     * </pre>
     *
     * <code>string started_at = 3;</code>
     * @return The startedAt.
     */
    java.lang.String getStartedAt();
    /**
     * <pre>
     * Дата и время начала планового периода. Формат значения RFC 3339
     * Пример данных: 2021-05-01T19:00:00+03:00
     * </pre>
     *
     * <code>string started_at = 3;</code>
     * @return The bytes for startedAt.
     */
    com.google.protobuf.ByteString
        getStartedAtBytes();

    /**
     * <pre>
     * Дата и время окончания планового периода. Формат значения RFC 3339
     * Пример данных: 2021-05-01T20:00:00+03:00
     * </pre>
     *
     * <code>string ended_at = 4;</code>
     * @return The endedAt.
     */
    java.lang.String getEndedAt();
    /**
     * <pre>
     * Дата и время окончания планового периода. Формат значения RFC 3339
     * Пример данных: 2021-05-01T20:00:00+03:00
     * </pre>
     *
     * <code>string ended_at = 4;</code>
     * @return The bytes for endedAt.
     */
    com.google.protobuf.ByteString
        getEndedAtBytes();

    /**
     * <pre>
     * Количество партнеров в плановом периоде, которому гарантирована оплата.
     * </pre>
     *
     * <code>uint32 peoples_count = 5;</code>
     * @return The peoplesCount.
     */
    int getPeoplesCount();

    /**
     * <pre>
     * Базовая гарантированная оплата - количество рублей в час, которые партнер
     * гарантированно получит за определенный час работы в смене.
     * </pre>
     *
     * <code>float base_guaranteed_payroll = 6;</code>
     * @return The baseGuaranteedPayroll.
     */
    float getBaseGuaranteedPayroll();

    /**
     * <pre>
     * Прогнозируемая базовая оплата - прогнозируемая оплата, которую партнер может
     * получить за смену (включает гарантированную оплату)
     * </pre>
     *
     * <code>float base_predicted_payroll = 7;</code>
     * @return The basePredictedPayroll.
     */
    float getBasePredictedPayroll();

    /**
     * <pre>
     * Признак планового периода, показывающий что данные период является периодом повышенного
     * спроса и что в нем применяется повышенный коэффициент оплаты
     * </pre>
     *
     * <code>bool surged = 8;</code>
     * @return The surged.
     */
    boolean getSurged();

    /**
     * <pre>
     * Список идентификаторов магазинов. Если список заполнен, то в рамках смены заказы поступают
     * только из указанных магазинов, если пуст, то со всех магазинов, доступных сервису диспетчеризации заказов
     * </pre>
     *
     * <code>repeated uint32 mapped_shops = 9;</code>
     * @return A list containing the mappedShops.
     */
    java.util.List<java.lang.Integer> getMappedShopsList();
    /**
     * <pre>
     * Список идентификаторов магазинов. Если список заполнен, то в рамках смены заказы поступают
     * только из указанных магазинов, если пуст, то со всех магазинов, доступных сервису диспетчеризации заказов
     * </pre>
     *
     * <code>repeated uint32 mapped_shops = 9;</code>
     * @return The count of mappedShops.
     */
    int getMappedShopsCount();
    /**
     * <pre>
     * Список идентификаторов магазинов. Если список заполнен, то в рамках смены заказы поступают
     * только из указанных магазинов, если пуст, то со всех магазинов, доступных сервису диспетчеризации заказов
     * </pre>
     *
     * <code>repeated uint32 mapped_shops = 9;</code>
     * @param index The index of the element to return.
     * @return The mappedShops at the given index.
     */
    int getMappedShops(int index);

    /**
     * <pre>
     * Признак активности планового периода
     * </pre>
     *
     * <code>bool is_active = 10;</code>
     * @return The isActive.
     */
    boolean getIsActive();

    /**
     * <pre>
     * Магазин для плановой доставки
     * </pre>
     *
     * <code>uint32 store_id = 11;</code>
     * @return The storeId.
     */
    int getStoreId();

    /**
     * <pre>
     * Объект с базовыми гарантированными оплатами по различным ролям - количество рублей в час, которые партнер
     * гарантированно получит за определенный час работы в смене.
     * </pre>
     *
     * <code>map&lt;string, float&gt; guaranteed_payroll = 12;</code>
     */
    int getGuaranteedPayrollCount();
    /**
     * <pre>
     * Объект с базовыми гарантированными оплатами по различным ролям - количество рублей в час, которые партнер
     * гарантированно получит за определенный час работы в смене.
     * </pre>
     *
     * <code>map&lt;string, float&gt; guaranteed_payroll = 12;</code>
     */
    boolean containsGuaranteedPayroll(
        java.lang.String key);
    /**
     * Use {@link #getGuaranteedPayrollMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.Float>
    getGuaranteedPayroll();
    /**
     * <pre>
     * Объект с базовыми гарантированными оплатами по различным ролям - количество рублей в час, которые партнер
     * гарантированно получит за определенный час работы в смене.
     * </pre>
     *
     * <code>map&lt;string, float&gt; guaranteed_payroll = 12;</code>
     */
    java.util.Map<java.lang.String, java.lang.Float>
    getGuaranteedPayrollMap();
    /**
     * <pre>
     * Объект с базовыми гарантированными оплатами по различным ролям - количество рублей в час, которые партнер
     * гарантированно получит за определенный час работы в смене.
     * </pre>
     *
     * <code>map&lt;string, float&gt; guaranteed_payroll = 12;</code>
     */

    float getGuaranteedPayrollOrDefault(
        java.lang.String key,
        float defaultValue);
    /**
     * <pre>
     * Объект с базовыми гарантированными оплатами по различным ролям - количество рублей в час, которые партнер
     * гарантированно получит за определенный час работы в смене.
     * </pre>
     *
     * <code>map&lt;string, float&gt; guaranteed_payroll = 12;</code>
     */

    float getGuaranteedPayrollOrThrow(
        java.lang.String key);

    /**
     * <pre>
     * Объект с прогнозируемой базовой оплатой по различным ролям - прогнозируемая оплата, которую партнер может
     * получить за смену (включает гарантированную оплату)
     * </pre>
     *
     * <code>map&lt;string, float&gt; predicted_payroll = 13;</code>
     */
    int getPredictedPayrollCount();
    /**
     * <pre>
     * Объект с прогнозируемой базовой оплатой по различным ролям - прогнозируемая оплата, которую партнер может
     * получить за смену (включает гарантированную оплату)
     * </pre>
     *
     * <code>map&lt;string, float&gt; predicted_payroll = 13;</code>
     */
    boolean containsPredictedPayroll(
        java.lang.String key);
    /**
     * Use {@link #getPredictedPayrollMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.Float>
    getPredictedPayroll();
    /**
     * <pre>
     * Объект с прогнозируемой базовой оплатой по различным ролям - прогнозируемая оплата, которую партнер может
     * получить за смену (включает гарантированную оплату)
     * </pre>
     *
     * <code>map&lt;string, float&gt; predicted_payroll = 13;</code>
     */
    java.util.Map<java.lang.String, java.lang.Float>
    getPredictedPayrollMap();
    /**
     * <pre>
     * Объект с прогнозируемой базовой оплатой по различным ролям - прогнозируемая оплата, которую партнер может
     * получить за смену (включает гарантированную оплату)
     * </pre>
     *
     * <code>map&lt;string, float&gt; predicted_payroll = 13;</code>
     */

    float getPredictedPayrollOrDefault(
        java.lang.String key,
        float defaultValue);
    /**
     * <pre>
     * Объект с прогнозируемой базовой оплатой по различным ролям - прогнозируемая оплата, которую партнер может
     * получить за смену (включает гарантированную оплату)
     * </pre>
     *
     * <code>map&lt;string, float&gt; predicted_payroll = 13;</code>
     */

    float getPredictedPayrollOrThrow(
        java.lang.String key);

    /**
     * <pre>
     * Глобальное время публикации UTC планового периода для партнера
     * </pre>
     *
     * <code>.google.protobuf.Timestamp published_time = 14;</code>
     * @return Whether the publishedTime field is set.
     */
    boolean hasPublishedTime();
    /**
     * <pre>
     * Глобальное время публикации UTC планового периода для партнера
     * </pre>
     *
     * <code>.google.protobuf.Timestamp published_time = 14;</code>
     * @return The publishedTime.
     */
    com.google.protobuf.Timestamp getPublishedTime();
    /**
     * <pre>
     * Глобальное время публикации UTC планового периода для партнера
     * </pre>
     *
     * <code>.google.protobuf.Timestamp published_time = 14;</code>
     */
    com.google.protobuf.TimestampOrBuilder getPublishedTimeOrBuilder();

    /**
     * <pre>
     * Объект с тегом и временем публикации планового периода для партнера
     * Пример данных: {"good_guy": "2021-05-01T19:00:00+03:00"}
     * </pre>
     *
     * <code>map&lt;string, string&gt; published_times = 15;</code>
     */
    int getPublishedTimesCount();
    /**
     * <pre>
     * Объект с тегом и временем публикации планового периода для партнера
     * Пример данных: {"good_guy": "2021-05-01T19:00:00+03:00"}
     * </pre>
     *
     * <code>map&lt;string, string&gt; published_times = 15;</code>
     */
    boolean containsPublishedTimes(
        java.lang.String key);
    /**
     * Use {@link #getPublishedTimesMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.String>
    getPublishedTimes();
    /**
     * <pre>
     * Объект с тегом и временем публикации планового периода для партнера
     * Пример данных: {"good_guy": "2021-05-01T19:00:00+03:00"}
     * </pre>
     *
     * <code>map&lt;string, string&gt; published_times = 15;</code>
     */
    java.util.Map<java.lang.String, java.lang.String>
    getPublishedTimesMap();
    /**
     * <pre>
     * Объект с тегом и временем публикации планового периода для партнера
     * Пример данных: {"good_guy": "2021-05-01T19:00:00+03:00"}
     * </pre>
     *
     * <code>map&lt;string, string&gt; published_times = 15;</code>
     */

    java.lang.String getPublishedTimesOrDefault(
        java.lang.String key,
        java.lang.String defaultValue);
    /**
     * <pre>
     * Объект с тегом и временем публикации планового периода для партнера
     * Пример данных: {"good_guy": "2021-05-01T19:00:00+03:00"}
     * </pre>
     *
     * <code>map&lt;string, string&gt; published_times = 15;</code>
     */

    java.lang.String getPublishedTimesOrThrow(
        java.lang.String key);

    /**
     * <pre>
     * Предполагаемое количество партнеров в плановом периоде, которым гарантирована оплата.
     * </pre>
     *
     * <code>uint32 peoples_count_predicted = 16;</code>
     * @return The peoplesCountPredicted.
     */
    int getPeoplesCountPredicted();

    /**
     * <pre>
     * Максимальное количество человек, которые могут взять планируемый период
     * Если отсутствует (nil/пустое), то ограничение не применяется
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_peoples_count = 17;</code>
     * @return Whether the maxPeoplesCount field is set.
     */
    boolean hasMaxPeoplesCount();
    /**
     * <pre>
     * Максимальное количество человек, которые могут взять планируемый период
     * Если отсутствует (nil/пустое), то ограничение не применяется
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_peoples_count = 17;</code>
     * @return The maxPeoplesCount.
     */
    com.google.protobuf.UInt32Value getMaxPeoplesCount();
    /**
     * <pre>
     * Максимальное количество человек, которые могут взять планируемый период
     * Если отсутствует (nil/пустое), то ограничение не применяется
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_peoples_count = 17;</code>
     */
    com.google.protobuf.UInt32ValueOrBuilder getMaxPeoplesCountOrBuilder();
  }
  /**
   * Protobuf type {@code shifts.PlanningPeriodItem}
   */
  public static final class PlanningPeriodItem extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:shifts.PlanningPeriodItem)
      PlanningPeriodItemOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use PlanningPeriodItem.newBuilder() to construct.
    private PlanningPeriodItem(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private PlanningPeriodItem() {
      role_ = "";
      startedAt_ = "";
      endedAt_ = "";
      mappedShops_ = emptyIntList();
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new PlanningPeriodItem();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private PlanningPeriodItem(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 8: {

              planningAreaId_ = input.readUInt32();
              break;
            }
            case 18: {
              java.lang.String s = input.readStringRequireUtf8();

              role_ = s;
              break;
            }
            case 26: {
              java.lang.String s = input.readStringRequireUtf8();

              startedAt_ = s;
              break;
            }
            case 34: {
              java.lang.String s = input.readStringRequireUtf8();

              endedAt_ = s;
              break;
            }
            case 40: {

              peoplesCount_ = input.readUInt32();
              break;
            }
            case 53: {

              baseGuaranteedPayroll_ = input.readFloat();
              break;
            }
            case 61: {

              basePredictedPayroll_ = input.readFloat();
              break;
            }
            case 64: {

              surged_ = input.readBool();
              break;
            }
            case 72: {
              if (!((mutable_bitField0_ & 0x00000001) != 0)) {
                mappedShops_ = newIntList();
                mutable_bitField0_ |= 0x00000001;
              }
              mappedShops_.addInt(input.readUInt32());
              break;
            }
            case 74: {
              int length = input.readRawVarint32();
              int limit = input.pushLimit(length);
              if (!((mutable_bitField0_ & 0x00000001) != 0) && input.getBytesUntilLimit() > 0) {
                mappedShops_ = newIntList();
                mutable_bitField0_ |= 0x00000001;
              }
              while (input.getBytesUntilLimit() > 0) {
                mappedShops_.addInt(input.readUInt32());
              }
              input.popLimit(limit);
              break;
            }
            case 80: {

              isActive_ = input.readBool();
              break;
            }
            case 88: {

              storeId_ = input.readUInt32();
              break;
            }
            case 98: {
              if (!((mutable_bitField0_ & 0x00000002) != 0)) {
                guaranteedPayroll_ = com.google.protobuf.MapField.newMapField(
                    GuaranteedPayrollDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000002;
              }
              com.google.protobuf.MapEntry<java.lang.String, java.lang.Float>
              guaranteedPayroll__ = input.readMessage(
                  GuaranteedPayrollDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              guaranteedPayroll_.getMutableMap().put(
                  guaranteedPayroll__.getKey(), guaranteedPayroll__.getValue());
              break;
            }
            case 106: {
              if (!((mutable_bitField0_ & 0x00000004) != 0)) {
                predictedPayroll_ = com.google.protobuf.MapField.newMapField(
                    PredictedPayrollDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000004;
              }
              com.google.protobuf.MapEntry<java.lang.String, java.lang.Float>
              predictedPayroll__ = input.readMessage(
                  PredictedPayrollDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              predictedPayroll_.getMutableMap().put(
                  predictedPayroll__.getKey(), predictedPayroll__.getValue());
              break;
            }
            case 114: {
              com.google.protobuf.Timestamp.Builder subBuilder = null;
              if (publishedTime_ != null) {
                subBuilder = publishedTime_.toBuilder();
              }
              publishedTime_ = input.readMessage(com.google.protobuf.Timestamp.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(publishedTime_);
                publishedTime_ = subBuilder.buildPartial();
              }

              break;
            }
            case 122: {
              if (!((mutable_bitField0_ & 0x00000008) != 0)) {
                publishedTimes_ = com.google.protobuf.MapField.newMapField(
                    PublishedTimesDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000008;
              }
              com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
              publishedTimes__ = input.readMessage(
                  PublishedTimesDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              publishedTimes_.getMutableMap().put(
                  publishedTimes__.getKey(), publishedTimes__.getValue());
              break;
            }
            case 128: {

              peoplesCountPredicted_ = input.readUInt32();
              break;
            }
            case 138: {
              com.google.protobuf.UInt32Value.Builder subBuilder = null;
              if (maxPeoplesCount_ != null) {
                subBuilder = maxPeoplesCount_.toBuilder();
              }
              maxPeoplesCount_ = input.readMessage(com.google.protobuf.UInt32Value.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(maxPeoplesCount_);
                maxPeoplesCount_ = subBuilder.buildPartial();
              }

              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000001) != 0)) {
          mappedShops_.makeImmutable(); // C
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return shifts.ImportPlanningPeriods.internal_static_shifts_PlanningPeriodItem_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    @java.lang.Override
    protected com.google.protobuf.MapField internalGetMapField(
        int number) {
      switch (number) {
        case 12:
          return internalGetGuaranteedPayroll();
        case 13:
          return internalGetPredictedPayroll();
        case 15:
          return internalGetPublishedTimes();
        default:
          throw new RuntimeException(
              "Invalid map field number: " + number);
      }
    }
    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return shifts.ImportPlanningPeriods.internal_static_shifts_PlanningPeriodItem_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              shifts.ImportPlanningPeriods.PlanningPeriodItem.class, shifts.ImportPlanningPeriods.PlanningPeriodItem.Builder.class);
    }

    public static final int PLANNING_AREA_ID_FIELD_NUMBER = 1;
    private int planningAreaId_;
    /**
     * <pre>
     * Зона планирования, в которой предполагается работа партнера.
     * В данный момент зона планирования эквивалентна территории доставки.
     * </pre>
     *
     * <code>uint32 planning_area_id = 1;</code>
     * @return The planningAreaId.
     */
    @java.lang.Override
    public int getPlanningAreaId() {
      return planningAreaId_;
    }

    public static final int ROLE_FIELD_NUMBER = 2;
    private volatile java.lang.Object role_;
    /**
     * <pre>
     * Роль партнера, для которой создается плановый период.
     * В данный момент в данном поле могут приняты следующие значения:
     * * driver - курьер
     * * shopper - сборщик
     * * universal - универсал
     * </pre>
     *
     * <code>string role = 2;</code>
     * @return The role.
     */
    @java.lang.Override
    public java.lang.String getRole() {
      java.lang.Object ref = role_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        role_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Роль партнера, для которой создается плановый период.
     * В данный момент в данном поле могут приняты следующие значения:
     * * driver - курьер
     * * shopper - сборщик
     * * universal - универсал
     * </pre>
     *
     * <code>string role = 2;</code>
     * @return The bytes for role.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getRoleBytes() {
      java.lang.Object ref = role_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        role_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int STARTED_AT_FIELD_NUMBER = 3;
    private volatile java.lang.Object startedAt_;
    /**
     * <pre>
     * Дата и время начала планового периода. Формат значения RFC 3339
     * Пример данных: 2021-05-01T19:00:00+03:00
     * </pre>
     *
     * <code>string started_at = 3;</code>
     * @return The startedAt.
     */
    @java.lang.Override
    public java.lang.String getStartedAt() {
      java.lang.Object ref = startedAt_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        startedAt_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Дата и время начала планового периода. Формат значения RFC 3339
     * Пример данных: 2021-05-01T19:00:00+03:00
     * </pre>
     *
     * <code>string started_at = 3;</code>
     * @return The bytes for startedAt.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getStartedAtBytes() {
      java.lang.Object ref = startedAt_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        startedAt_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int ENDED_AT_FIELD_NUMBER = 4;
    private volatile java.lang.Object endedAt_;
    /**
     * <pre>
     * Дата и время окончания планового периода. Формат значения RFC 3339
     * Пример данных: 2021-05-01T20:00:00+03:00
     * </pre>
     *
     * <code>string ended_at = 4;</code>
     * @return The endedAt.
     */
    @java.lang.Override
    public java.lang.String getEndedAt() {
      java.lang.Object ref = endedAt_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        endedAt_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Дата и время окончания планового периода. Формат значения RFC 3339
     * Пример данных: 2021-05-01T20:00:00+03:00
     * </pre>
     *
     * <code>string ended_at = 4;</code>
     * @return The bytes for endedAt.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getEndedAtBytes() {
      java.lang.Object ref = endedAt_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        endedAt_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int PEOPLES_COUNT_FIELD_NUMBER = 5;
    private int peoplesCount_;
    /**
     * <pre>
     * Количество партнеров в плановом периоде, которому гарантирована оплата.
     * </pre>
     *
     * <code>uint32 peoples_count = 5;</code>
     * @return The peoplesCount.
     */
    @java.lang.Override
    public int getPeoplesCount() {
      return peoplesCount_;
    }

    public static final int BASE_GUARANTEED_PAYROLL_FIELD_NUMBER = 6;
    private float baseGuaranteedPayroll_;
    /**
     * <pre>
     * Базовая гарантированная оплата - количество рублей в час, которые партнер
     * гарантированно получит за определенный час работы в смене.
     * </pre>
     *
     * <code>float base_guaranteed_payroll = 6;</code>
     * @return The baseGuaranteedPayroll.
     */
    @java.lang.Override
    public float getBaseGuaranteedPayroll() {
      return baseGuaranteedPayroll_;
    }

    public static final int BASE_PREDICTED_PAYROLL_FIELD_NUMBER = 7;
    private float basePredictedPayroll_;
    /**
     * <pre>
     * Прогнозируемая базовая оплата - прогнозируемая оплата, которую партнер может
     * получить за смену (включает гарантированную оплату)
     * </pre>
     *
     * <code>float base_predicted_payroll = 7;</code>
     * @return The basePredictedPayroll.
     */
    @java.lang.Override
    public float getBasePredictedPayroll() {
      return basePredictedPayroll_;
    }

    public static final int SURGED_FIELD_NUMBER = 8;
    private boolean surged_;
    /**
     * <pre>
     * Признак планового периода, показывающий что данные период является периодом повышенного
     * спроса и что в нем применяется повышенный коэффициент оплаты
     * </pre>
     *
     * <code>bool surged = 8;</code>
     * @return The surged.
     */
    @java.lang.Override
    public boolean getSurged() {
      return surged_;
    }

    public static final int MAPPED_SHOPS_FIELD_NUMBER = 9;
    private com.google.protobuf.Internal.IntList mappedShops_;
    /**
     * <pre>
     * Список идентификаторов магазинов. Если список заполнен, то в рамках смены заказы поступают
     * только из указанных магазинов, если пуст, то со всех магазинов, доступных сервису диспетчеризации заказов
     * </pre>
     *
     * <code>repeated uint32 mapped_shops = 9;</code>
     * @return A list containing the mappedShops.
     */
    @java.lang.Override
    public java.util.List<java.lang.Integer>
        getMappedShopsList() {
      return mappedShops_;
    }
    /**
     * <pre>
     * Список идентификаторов магазинов. Если список заполнен, то в рамках смены заказы поступают
     * только из указанных магазинов, если пуст, то со всех магазинов, доступных сервису диспетчеризации заказов
     * </pre>
     *
     * <code>repeated uint32 mapped_shops = 9;</code>
     * @return The count of mappedShops.
     */
    public int getMappedShopsCount() {
      return mappedShops_.size();
    }
    /**
     * <pre>
     * Список идентификаторов магазинов. Если список заполнен, то в рамках смены заказы поступают
     * только из указанных магазинов, если пуст, то со всех магазинов, доступных сервису диспетчеризации заказов
     * </pre>
     *
     * <code>repeated uint32 mapped_shops = 9;</code>
     * @param index The index of the element to return.
     * @return The mappedShops at the given index.
     */
    public int getMappedShops(int index) {
      return mappedShops_.getInt(index);
    }
    private int mappedShopsMemoizedSerializedSize = -1;

    public static final int IS_ACTIVE_FIELD_NUMBER = 10;
    private boolean isActive_;
    /**
     * <pre>
     * Признак активности планового периода
     * </pre>
     *
     * <code>bool is_active = 10;</code>
     * @return The isActive.
     */
    @java.lang.Override
    public boolean getIsActive() {
      return isActive_;
    }

    public static final int STORE_ID_FIELD_NUMBER = 11;
    private int storeId_;
    /**
     * <pre>
     * Магазин для плановой доставки
     * </pre>
     *
     * <code>uint32 store_id = 11;</code>
     * @return The storeId.
     */
    @java.lang.Override
    public int getStoreId() {
      return storeId_;
    }

    public static final int GUARANTEED_PAYROLL_FIELD_NUMBER = 12;
    private static final class GuaranteedPayrollDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, java.lang.Float> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, java.lang.Float>newDefaultInstance(
                  shifts.ImportPlanningPeriods.internal_static_shifts_PlanningPeriodItem_GuaranteedPayrollEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.FLOAT,
                  0F);
    }
    private com.google.protobuf.MapField<
        java.lang.String, java.lang.Float> guaranteedPayroll_;
    private com.google.protobuf.MapField<java.lang.String, java.lang.Float>
    internalGetGuaranteedPayroll() {
      if (guaranteedPayroll_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            GuaranteedPayrollDefaultEntryHolder.defaultEntry);
      }
      return guaranteedPayroll_;
    }

    public int getGuaranteedPayrollCount() {
      return internalGetGuaranteedPayroll().getMap().size();
    }
    /**
     * <pre>
     * Объект с базовыми гарантированными оплатами по различным ролям - количество рублей в час, которые партнер
     * гарантированно получит за определенный час работы в смене.
     * </pre>
     *
     * <code>map&lt;string, float&gt; guaranteed_payroll = 12;</code>
     */

    @java.lang.Override
    public boolean containsGuaranteedPayroll(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      return internalGetGuaranteedPayroll().getMap().containsKey(key);
    }
    /**
     * Use {@link #getGuaranteedPayrollMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.Float> getGuaranteedPayroll() {
      return getGuaranteedPayrollMap();
    }
    /**
     * <pre>
     * Объект с базовыми гарантированными оплатами по различным ролям - количество рублей в час, которые партнер
     * гарантированно получит за определенный час работы в смене.
     * </pre>
     *
     * <code>map&lt;string, float&gt; guaranteed_payroll = 12;</code>
     */
    @java.lang.Override

    public java.util.Map<java.lang.String, java.lang.Float> getGuaranteedPayrollMap() {
      return internalGetGuaranteedPayroll().getMap();
    }
    /**
     * <pre>
     * Объект с базовыми гарантированными оплатами по различным ролям - количество рублей в час, которые партнер
     * гарантированно получит за определенный час работы в смене.
     * </pre>
     *
     * <code>map&lt;string, float&gt; guaranteed_payroll = 12;</code>
     */
    @java.lang.Override

    public float getGuaranteedPayrollOrDefault(
        java.lang.String key,
        float defaultValue) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.Float> map =
          internalGetGuaranteedPayroll().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * Объект с базовыми гарантированными оплатами по различным ролям - количество рублей в час, которые партнер
     * гарантированно получит за определенный час работы в смене.
     * </pre>
     *
     * <code>map&lt;string, float&gt; guaranteed_payroll = 12;</code>
     */
    @java.lang.Override

    public float getGuaranteedPayrollOrThrow(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.Float> map =
          internalGetGuaranteedPayroll().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    public static final int PREDICTED_PAYROLL_FIELD_NUMBER = 13;
    private static final class PredictedPayrollDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, java.lang.Float> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, java.lang.Float>newDefaultInstance(
                  shifts.ImportPlanningPeriods.internal_static_shifts_PlanningPeriodItem_PredictedPayrollEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.FLOAT,
                  0F);
    }
    private com.google.protobuf.MapField<
        java.lang.String, java.lang.Float> predictedPayroll_;
    private com.google.protobuf.MapField<java.lang.String, java.lang.Float>
    internalGetPredictedPayroll() {
      if (predictedPayroll_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            PredictedPayrollDefaultEntryHolder.defaultEntry);
      }
      return predictedPayroll_;
    }

    public int getPredictedPayrollCount() {
      return internalGetPredictedPayroll().getMap().size();
    }
    /**
     * <pre>
     * Объект с прогнозируемой базовой оплатой по различным ролям - прогнозируемая оплата, которую партнер может
     * получить за смену (включает гарантированную оплату)
     * </pre>
     *
     * <code>map&lt;string, float&gt; predicted_payroll = 13;</code>
     */

    @java.lang.Override
    public boolean containsPredictedPayroll(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      return internalGetPredictedPayroll().getMap().containsKey(key);
    }
    /**
     * Use {@link #getPredictedPayrollMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.Float> getPredictedPayroll() {
      return getPredictedPayrollMap();
    }
    /**
     * <pre>
     * Объект с прогнозируемой базовой оплатой по различным ролям - прогнозируемая оплата, которую партнер может
     * получить за смену (включает гарантированную оплату)
     * </pre>
     *
     * <code>map&lt;string, float&gt; predicted_payroll = 13;</code>
     */
    @java.lang.Override

    public java.util.Map<java.lang.String, java.lang.Float> getPredictedPayrollMap() {
      return internalGetPredictedPayroll().getMap();
    }
    /**
     * <pre>
     * Объект с прогнозируемой базовой оплатой по различным ролям - прогнозируемая оплата, которую партнер может
     * получить за смену (включает гарантированную оплату)
     * </pre>
     *
     * <code>map&lt;string, float&gt; predicted_payroll = 13;</code>
     */
    @java.lang.Override

    public float getPredictedPayrollOrDefault(
        java.lang.String key,
        float defaultValue) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.Float> map =
          internalGetPredictedPayroll().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * Объект с прогнозируемой базовой оплатой по различным ролям - прогнозируемая оплата, которую партнер может
     * получить за смену (включает гарантированную оплату)
     * </pre>
     *
     * <code>map&lt;string, float&gt; predicted_payroll = 13;</code>
     */
    @java.lang.Override

    public float getPredictedPayrollOrThrow(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.Float> map =
          internalGetPredictedPayroll().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    public static final int PUBLISHED_TIME_FIELD_NUMBER = 14;
    private com.google.protobuf.Timestamp publishedTime_;
    /**
     * <pre>
     * Глобальное время публикации UTC планового периода для партнера
     * </pre>
     *
     * <code>.google.protobuf.Timestamp published_time = 14;</code>
     * @return Whether the publishedTime field is set.
     */
    @java.lang.Override
    public boolean hasPublishedTime() {
      return publishedTime_ != null;
    }
    /**
     * <pre>
     * Глобальное время публикации UTC планового периода для партнера
     * </pre>
     *
     * <code>.google.protobuf.Timestamp published_time = 14;</code>
     * @return The publishedTime.
     */
    @java.lang.Override
    public com.google.protobuf.Timestamp getPublishedTime() {
      return publishedTime_ == null ? com.google.protobuf.Timestamp.getDefaultInstance() : publishedTime_;
    }
    /**
     * <pre>
     * Глобальное время публикации UTC планового периода для партнера
     * </pre>
     *
     * <code>.google.protobuf.Timestamp published_time = 14;</code>
     */
    @java.lang.Override
    public com.google.protobuf.TimestampOrBuilder getPublishedTimeOrBuilder() {
      return getPublishedTime();
    }

    public static final int PUBLISHED_TIMES_FIELD_NUMBER = 15;
    private static final class PublishedTimesDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, java.lang.String> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, java.lang.String>newDefaultInstance(
                  shifts.ImportPlanningPeriods.internal_static_shifts_PlanningPeriodItem_PublishedTimesEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "");
    }
    private com.google.protobuf.MapField<
        java.lang.String, java.lang.String> publishedTimes_;
    private com.google.protobuf.MapField<java.lang.String, java.lang.String>
    internalGetPublishedTimes() {
      if (publishedTimes_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            PublishedTimesDefaultEntryHolder.defaultEntry);
      }
      return publishedTimes_;
    }

    public int getPublishedTimesCount() {
      return internalGetPublishedTimes().getMap().size();
    }
    /**
     * <pre>
     * Объект с тегом и временем публикации планового периода для партнера
     * Пример данных: {"good_guy": "2021-05-01T19:00:00+03:00"}
     * </pre>
     *
     * <code>map&lt;string, string&gt; published_times = 15;</code>
     */

    @java.lang.Override
    public boolean containsPublishedTimes(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      return internalGetPublishedTimes().getMap().containsKey(key);
    }
    /**
     * Use {@link #getPublishedTimesMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String> getPublishedTimes() {
      return getPublishedTimesMap();
    }
    /**
     * <pre>
     * Объект с тегом и временем публикации планового периода для партнера
     * Пример данных: {"good_guy": "2021-05-01T19:00:00+03:00"}
     * </pre>
     *
     * <code>map&lt;string, string&gt; published_times = 15;</code>
     */
    @java.lang.Override

    public java.util.Map<java.lang.String, java.lang.String> getPublishedTimesMap() {
      return internalGetPublishedTimes().getMap();
    }
    /**
     * <pre>
     * Объект с тегом и временем публикации планового периода для партнера
     * Пример данных: {"good_guy": "2021-05-01T19:00:00+03:00"}
     * </pre>
     *
     * <code>map&lt;string, string&gt; published_times = 15;</code>
     */
    @java.lang.Override

    public java.lang.String getPublishedTimesOrDefault(
        java.lang.String key,
        java.lang.String defaultValue) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetPublishedTimes().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * Объект с тегом и временем публикации планового периода для партнера
     * Пример данных: {"good_guy": "2021-05-01T19:00:00+03:00"}
     * </pre>
     *
     * <code>map&lt;string, string&gt; published_times = 15;</code>
     */
    @java.lang.Override

    public java.lang.String getPublishedTimesOrThrow(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetPublishedTimes().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    public static final int PEOPLES_COUNT_PREDICTED_FIELD_NUMBER = 16;
    private int peoplesCountPredicted_;
    /**
     * <pre>
     * Предполагаемое количество партнеров в плановом периоде, которым гарантирована оплата.
     * </pre>
     *
     * <code>uint32 peoples_count_predicted = 16;</code>
     * @return The peoplesCountPredicted.
     */
    @java.lang.Override
    public int getPeoplesCountPredicted() {
      return peoplesCountPredicted_;
    }

    public static final int MAX_PEOPLES_COUNT_FIELD_NUMBER = 17;
    private com.google.protobuf.UInt32Value maxPeoplesCount_;
    /**
     * <pre>
     * Максимальное количество человек, которые могут взять планируемый период
     * Если отсутствует (nil/пустое), то ограничение не применяется
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_peoples_count = 17;</code>
     * @return Whether the maxPeoplesCount field is set.
     */
    @java.lang.Override
    public boolean hasMaxPeoplesCount() {
      return maxPeoplesCount_ != null;
    }
    /**
     * <pre>
     * Максимальное количество человек, которые могут взять планируемый период
     * Если отсутствует (nil/пустое), то ограничение не применяется
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_peoples_count = 17;</code>
     * @return The maxPeoplesCount.
     */
    @java.lang.Override
    public com.google.protobuf.UInt32Value getMaxPeoplesCount() {
      return maxPeoplesCount_ == null ? com.google.protobuf.UInt32Value.getDefaultInstance() : maxPeoplesCount_;
    }
    /**
     * <pre>
     * Максимальное количество человек, которые могут взять планируемый период
     * Если отсутствует (nil/пустое), то ограничение не применяется
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_peoples_count = 17;</code>
     */
    @java.lang.Override
    public com.google.protobuf.UInt32ValueOrBuilder getMaxPeoplesCountOrBuilder() {
      return getMaxPeoplesCount();
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      getSerializedSize();
      if (planningAreaId_ != 0) {
        output.writeUInt32(1, planningAreaId_);
      }
      if (!getRoleBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, role_);
      }
      if (!getStartedAtBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 3, startedAt_);
      }
      if (!getEndedAtBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 4, endedAt_);
      }
      if (peoplesCount_ != 0) {
        output.writeUInt32(5, peoplesCount_);
      }
      if (baseGuaranteedPayroll_ != 0F) {
        output.writeFloat(6, baseGuaranteedPayroll_);
      }
      if (basePredictedPayroll_ != 0F) {
        output.writeFloat(7, basePredictedPayroll_);
      }
      if (surged_ != false) {
        output.writeBool(8, surged_);
      }
      if (getMappedShopsList().size() > 0) {
        output.writeUInt32NoTag(74);
        output.writeUInt32NoTag(mappedShopsMemoizedSerializedSize);
      }
      for (int i = 0; i < mappedShops_.size(); i++) {
        output.writeUInt32NoTag(mappedShops_.getInt(i));
      }
      if (isActive_ != false) {
        output.writeBool(10, isActive_);
      }
      if (storeId_ != 0) {
        output.writeUInt32(11, storeId_);
      }
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetGuaranteedPayroll(),
          GuaranteedPayrollDefaultEntryHolder.defaultEntry,
          12);
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetPredictedPayroll(),
          PredictedPayrollDefaultEntryHolder.defaultEntry,
          13);
      if (publishedTime_ != null) {
        output.writeMessage(14, getPublishedTime());
      }
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetPublishedTimes(),
          PublishedTimesDefaultEntryHolder.defaultEntry,
          15);
      if (peoplesCountPredicted_ != 0) {
        output.writeUInt32(16, peoplesCountPredicted_);
      }
      if (maxPeoplesCount_ != null) {
        output.writeMessage(17, getMaxPeoplesCount());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (planningAreaId_ != 0) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(1, planningAreaId_);
      }
      if (!getRoleBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, role_);
      }
      if (!getStartedAtBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, startedAt_);
      }
      if (!getEndedAtBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(4, endedAt_);
      }
      if (peoplesCount_ != 0) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(5, peoplesCount_);
      }
      if (baseGuaranteedPayroll_ != 0F) {
        size += com.google.protobuf.CodedOutputStream
          .computeFloatSize(6, baseGuaranteedPayroll_);
      }
      if (basePredictedPayroll_ != 0F) {
        size += com.google.protobuf.CodedOutputStream
          .computeFloatSize(7, basePredictedPayroll_);
      }
      if (surged_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(8, surged_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < mappedShops_.size(); i++) {
          dataSize += com.google.protobuf.CodedOutputStream
            .computeUInt32SizeNoTag(mappedShops_.getInt(i));
        }
        size += dataSize;
        if (!getMappedShopsList().isEmpty()) {
          size += 1;
          size += com.google.protobuf.CodedOutputStream
              .computeInt32SizeNoTag(dataSize);
        }
        mappedShopsMemoizedSerializedSize = dataSize;
      }
      if (isActive_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(10, isActive_);
      }
      if (storeId_ != 0) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(11, storeId_);
      }
      for (java.util.Map.Entry<java.lang.String, java.lang.Float> entry
           : internalGetGuaranteedPayroll().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, java.lang.Float>
        guaranteedPayroll__ = GuaranteedPayrollDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(12, guaranteedPayroll__);
      }
      for (java.util.Map.Entry<java.lang.String, java.lang.Float> entry
           : internalGetPredictedPayroll().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, java.lang.Float>
        predictedPayroll__ = PredictedPayrollDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(13, predictedPayroll__);
      }
      if (publishedTime_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(14, getPublishedTime());
      }
      for (java.util.Map.Entry<java.lang.String, java.lang.String> entry
           : internalGetPublishedTimes().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
        publishedTimes__ = PublishedTimesDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(15, publishedTimes__);
      }
      if (peoplesCountPredicted_ != 0) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(16, peoplesCountPredicted_);
      }
      if (maxPeoplesCount_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(17, getMaxPeoplesCount());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof shifts.ImportPlanningPeriods.PlanningPeriodItem)) {
        return super.equals(obj);
      }
      shifts.ImportPlanningPeriods.PlanningPeriodItem other = (shifts.ImportPlanningPeriods.PlanningPeriodItem) obj;

      if (getPlanningAreaId()
          != other.getPlanningAreaId()) return false;
      if (!getRole()
          .equals(other.getRole())) return false;
      if (!getStartedAt()
          .equals(other.getStartedAt())) return false;
      if (!getEndedAt()
          .equals(other.getEndedAt())) return false;
      if (getPeoplesCount()
          != other.getPeoplesCount()) return false;
      if (java.lang.Float.floatToIntBits(getBaseGuaranteedPayroll())
          != java.lang.Float.floatToIntBits(
              other.getBaseGuaranteedPayroll())) return false;
      if (java.lang.Float.floatToIntBits(getBasePredictedPayroll())
          != java.lang.Float.floatToIntBits(
              other.getBasePredictedPayroll())) return false;
      if (getSurged()
          != other.getSurged()) return false;
      if (!getMappedShopsList()
          .equals(other.getMappedShopsList())) return false;
      if (getIsActive()
          != other.getIsActive()) return false;
      if (getStoreId()
          != other.getStoreId()) return false;
      if (!internalGetGuaranteedPayroll().equals(
          other.internalGetGuaranteedPayroll())) return false;
      if (!internalGetPredictedPayroll().equals(
          other.internalGetPredictedPayroll())) return false;
      if (hasPublishedTime() != other.hasPublishedTime()) return false;
      if (hasPublishedTime()) {
        if (!getPublishedTime()
            .equals(other.getPublishedTime())) return false;
      }
      if (!internalGetPublishedTimes().equals(
          other.internalGetPublishedTimes())) return false;
      if (getPeoplesCountPredicted()
          != other.getPeoplesCountPredicted()) return false;
      if (hasMaxPeoplesCount() != other.hasMaxPeoplesCount()) return false;
      if (hasMaxPeoplesCount()) {
        if (!getMaxPeoplesCount()
            .equals(other.getMaxPeoplesCount())) return false;
      }
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + PLANNING_AREA_ID_FIELD_NUMBER;
      hash = (53 * hash) + getPlanningAreaId();
      hash = (37 * hash) + ROLE_FIELD_NUMBER;
      hash = (53 * hash) + getRole().hashCode();
      hash = (37 * hash) + STARTED_AT_FIELD_NUMBER;
      hash = (53 * hash) + getStartedAt().hashCode();
      hash = (37 * hash) + ENDED_AT_FIELD_NUMBER;
      hash = (53 * hash) + getEndedAt().hashCode();
      hash = (37 * hash) + PEOPLES_COUNT_FIELD_NUMBER;
      hash = (53 * hash) + getPeoplesCount();
      hash = (37 * hash) + BASE_GUARANTEED_PAYROLL_FIELD_NUMBER;
      hash = (53 * hash) + java.lang.Float.floatToIntBits(
          getBaseGuaranteedPayroll());
      hash = (37 * hash) + BASE_PREDICTED_PAYROLL_FIELD_NUMBER;
      hash = (53 * hash) + java.lang.Float.floatToIntBits(
          getBasePredictedPayroll());
      hash = (37 * hash) + SURGED_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getSurged());
      if (getMappedShopsCount() > 0) {
        hash = (37 * hash) + MAPPED_SHOPS_FIELD_NUMBER;
        hash = (53 * hash) + getMappedShopsList().hashCode();
      }
      hash = (37 * hash) + IS_ACTIVE_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getIsActive());
      hash = (37 * hash) + STORE_ID_FIELD_NUMBER;
      hash = (53 * hash) + getStoreId();
      if (!internalGetGuaranteedPayroll().getMap().isEmpty()) {
        hash = (37 * hash) + GUARANTEED_PAYROLL_FIELD_NUMBER;
        hash = (53 * hash) + internalGetGuaranteedPayroll().hashCode();
      }
      if (!internalGetPredictedPayroll().getMap().isEmpty()) {
        hash = (37 * hash) + PREDICTED_PAYROLL_FIELD_NUMBER;
        hash = (53 * hash) + internalGetPredictedPayroll().hashCode();
      }
      if (hasPublishedTime()) {
        hash = (37 * hash) + PUBLISHED_TIME_FIELD_NUMBER;
        hash = (53 * hash) + getPublishedTime().hashCode();
      }
      if (!internalGetPublishedTimes().getMap().isEmpty()) {
        hash = (37 * hash) + PUBLISHED_TIMES_FIELD_NUMBER;
        hash = (53 * hash) + internalGetPublishedTimes().hashCode();
      }
      hash = (37 * hash) + PEOPLES_COUNT_PREDICTED_FIELD_NUMBER;
      hash = (53 * hash) + getPeoplesCountPredicted();
      if (hasMaxPeoplesCount()) {
        hash = (37 * hash) + MAX_PEOPLES_COUNT_FIELD_NUMBER;
        hash = (53 * hash) + getMaxPeoplesCount().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static shifts.ImportPlanningPeriods.PlanningPeriodItem parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static shifts.ImportPlanningPeriods.PlanningPeriodItem parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static shifts.ImportPlanningPeriods.PlanningPeriodItem parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static shifts.ImportPlanningPeriods.PlanningPeriodItem parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static shifts.ImportPlanningPeriods.PlanningPeriodItem parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static shifts.ImportPlanningPeriods.PlanningPeriodItem parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static shifts.ImportPlanningPeriods.PlanningPeriodItem parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static shifts.ImportPlanningPeriods.PlanningPeriodItem parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static shifts.ImportPlanningPeriods.PlanningPeriodItem parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static shifts.ImportPlanningPeriods.PlanningPeriodItem parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static shifts.ImportPlanningPeriods.PlanningPeriodItem parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static shifts.ImportPlanningPeriods.PlanningPeriodItem parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(shifts.ImportPlanningPeriods.PlanningPeriodItem prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code shifts.PlanningPeriodItem}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:shifts.PlanningPeriodItem)
        shifts.ImportPlanningPeriods.PlanningPeriodItemOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return shifts.ImportPlanningPeriods.internal_static_shifts_PlanningPeriodItem_descriptor;
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMapField(
          int number) {
        switch (number) {
          case 12:
            return internalGetGuaranteedPayroll();
          case 13:
            return internalGetPredictedPayroll();
          case 15:
            return internalGetPublishedTimes();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMutableMapField(
          int number) {
        switch (number) {
          case 12:
            return internalGetMutableGuaranteedPayroll();
          case 13:
            return internalGetMutablePredictedPayroll();
          case 15:
            return internalGetMutablePublishedTimes();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return shifts.ImportPlanningPeriods.internal_static_shifts_PlanningPeriodItem_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                shifts.ImportPlanningPeriods.PlanningPeriodItem.class, shifts.ImportPlanningPeriods.PlanningPeriodItem.Builder.class);
      }

      // Construct using shifts.ImportPlanningPeriods.PlanningPeriodItem.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        planningAreaId_ = 0;

        role_ = "";

        startedAt_ = "";

        endedAt_ = "";

        peoplesCount_ = 0;

        baseGuaranteedPayroll_ = 0F;

        basePredictedPayroll_ = 0F;

        surged_ = false;

        mappedShops_ = emptyIntList();
        bitField0_ = (bitField0_ & ~0x00000001);
        isActive_ = false;

        storeId_ = 0;

        internalGetMutableGuaranteedPayroll().clear();
        internalGetMutablePredictedPayroll().clear();
        if (publishedTimeBuilder_ == null) {
          publishedTime_ = null;
        } else {
          publishedTime_ = null;
          publishedTimeBuilder_ = null;
        }
        internalGetMutablePublishedTimes().clear();
        peoplesCountPredicted_ = 0;

        if (maxPeoplesCountBuilder_ == null) {
          maxPeoplesCount_ = null;
        } else {
          maxPeoplesCount_ = null;
          maxPeoplesCountBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return shifts.ImportPlanningPeriods.internal_static_shifts_PlanningPeriodItem_descriptor;
      }

      @java.lang.Override
      public shifts.ImportPlanningPeriods.PlanningPeriodItem getDefaultInstanceForType() {
        return shifts.ImportPlanningPeriods.PlanningPeriodItem.getDefaultInstance();
      }

      @java.lang.Override
      public shifts.ImportPlanningPeriods.PlanningPeriodItem build() {
        shifts.ImportPlanningPeriods.PlanningPeriodItem result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public shifts.ImportPlanningPeriods.PlanningPeriodItem buildPartial() {
        shifts.ImportPlanningPeriods.PlanningPeriodItem result = new shifts.ImportPlanningPeriods.PlanningPeriodItem(this);
        int from_bitField0_ = bitField0_;
        result.planningAreaId_ = planningAreaId_;
        result.role_ = role_;
        result.startedAt_ = startedAt_;
        result.endedAt_ = endedAt_;
        result.peoplesCount_ = peoplesCount_;
        result.baseGuaranteedPayroll_ = baseGuaranteedPayroll_;
        result.basePredictedPayroll_ = basePredictedPayroll_;
        result.surged_ = surged_;
        if (((bitField0_ & 0x00000001) != 0)) {
          mappedShops_.makeImmutable();
          bitField0_ = (bitField0_ & ~0x00000001);
        }
        result.mappedShops_ = mappedShops_;
        result.isActive_ = isActive_;
        result.storeId_ = storeId_;
        result.guaranteedPayroll_ = internalGetGuaranteedPayroll();
        result.guaranteedPayroll_.makeImmutable();
        result.predictedPayroll_ = internalGetPredictedPayroll();
        result.predictedPayroll_.makeImmutable();
        if (publishedTimeBuilder_ == null) {
          result.publishedTime_ = publishedTime_;
        } else {
          result.publishedTime_ = publishedTimeBuilder_.build();
        }
        result.publishedTimes_ = internalGetPublishedTimes();
        result.publishedTimes_.makeImmutable();
        result.peoplesCountPredicted_ = peoplesCountPredicted_;
        if (maxPeoplesCountBuilder_ == null) {
          result.maxPeoplesCount_ = maxPeoplesCount_;
        } else {
          result.maxPeoplesCount_ = maxPeoplesCountBuilder_.build();
        }
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof shifts.ImportPlanningPeriods.PlanningPeriodItem) {
          return mergeFrom((shifts.ImportPlanningPeriods.PlanningPeriodItem)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(shifts.ImportPlanningPeriods.PlanningPeriodItem other) {
        if (other == shifts.ImportPlanningPeriods.PlanningPeriodItem.getDefaultInstance()) return this;
        if (other.getPlanningAreaId() != 0) {
          setPlanningAreaId(other.getPlanningAreaId());
        }
        if (!other.getRole().isEmpty()) {
          role_ = other.role_;
          onChanged();
        }
        if (!other.getStartedAt().isEmpty()) {
          startedAt_ = other.startedAt_;
          onChanged();
        }
        if (!other.getEndedAt().isEmpty()) {
          endedAt_ = other.endedAt_;
          onChanged();
        }
        if (other.getPeoplesCount() != 0) {
          setPeoplesCount(other.getPeoplesCount());
        }
        if (other.getBaseGuaranteedPayroll() != 0F) {
          setBaseGuaranteedPayroll(other.getBaseGuaranteedPayroll());
        }
        if (other.getBasePredictedPayroll() != 0F) {
          setBasePredictedPayroll(other.getBasePredictedPayroll());
        }
        if (other.getSurged() != false) {
          setSurged(other.getSurged());
        }
        if (!other.mappedShops_.isEmpty()) {
          if (mappedShops_.isEmpty()) {
            mappedShops_ = other.mappedShops_;
            bitField0_ = (bitField0_ & ~0x00000001);
          } else {
            ensureMappedShopsIsMutable();
            mappedShops_.addAll(other.mappedShops_);
          }
          onChanged();
        }
        if (other.getIsActive() != false) {
          setIsActive(other.getIsActive());
        }
        if (other.getStoreId() != 0) {
          setStoreId(other.getStoreId());
        }
        internalGetMutableGuaranteedPayroll().mergeFrom(
            other.internalGetGuaranteedPayroll());
        internalGetMutablePredictedPayroll().mergeFrom(
            other.internalGetPredictedPayroll());
        if (other.hasPublishedTime()) {
          mergePublishedTime(other.getPublishedTime());
        }
        internalGetMutablePublishedTimes().mergeFrom(
            other.internalGetPublishedTimes());
        if (other.getPeoplesCountPredicted() != 0) {
          setPeoplesCountPredicted(other.getPeoplesCountPredicted());
        }
        if (other.hasMaxPeoplesCount()) {
          mergeMaxPeoplesCount(other.getMaxPeoplesCount());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        shifts.ImportPlanningPeriods.PlanningPeriodItem parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (shifts.ImportPlanningPeriods.PlanningPeriodItem) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private int planningAreaId_ ;
      /**
       * <pre>
       * Зона планирования, в которой предполагается работа партнера.
       * В данный момент зона планирования эквивалентна территории доставки.
       * </pre>
       *
       * <code>uint32 planning_area_id = 1;</code>
       * @return The planningAreaId.
       */
      @java.lang.Override
      public int getPlanningAreaId() {
        return planningAreaId_;
      }
      /**
       * <pre>
       * Зона планирования, в которой предполагается работа партнера.
       * В данный момент зона планирования эквивалентна территории доставки.
       * </pre>
       *
       * <code>uint32 planning_area_id = 1;</code>
       * @param value The planningAreaId to set.
       * @return This builder for chaining.
       */
      public Builder setPlanningAreaId(int value) {
        
        planningAreaId_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Зона планирования, в которой предполагается работа партнера.
       * В данный момент зона планирования эквивалентна территории доставки.
       * </pre>
       *
       * <code>uint32 planning_area_id = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearPlanningAreaId() {
        
        planningAreaId_ = 0;
        onChanged();
        return this;
      }

      private java.lang.Object role_ = "";
      /**
       * <pre>
       * Роль партнера, для которой создается плановый период.
       * В данный момент в данном поле могут приняты следующие значения:
       * * driver - курьер
       * * shopper - сборщик
       * * universal - универсал
       * </pre>
       *
       * <code>string role = 2;</code>
       * @return The role.
       */
      public java.lang.String getRole() {
        java.lang.Object ref = role_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          role_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Роль партнера, для которой создается плановый период.
       * В данный момент в данном поле могут приняты следующие значения:
       * * driver - курьер
       * * shopper - сборщик
       * * universal - универсал
       * </pre>
       *
       * <code>string role = 2;</code>
       * @return The bytes for role.
       */
      public com.google.protobuf.ByteString
          getRoleBytes() {
        java.lang.Object ref = role_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          role_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Роль партнера, для которой создается плановый период.
       * В данный момент в данном поле могут приняты следующие значения:
       * * driver - курьер
       * * shopper - сборщик
       * * universal - универсал
       * </pre>
       *
       * <code>string role = 2;</code>
       * @param value The role to set.
       * @return This builder for chaining.
       */
      public Builder setRole(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        role_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Роль партнера, для которой создается плановый период.
       * В данный момент в данном поле могут приняты следующие значения:
       * * driver - курьер
       * * shopper - сборщик
       * * universal - универсал
       * </pre>
       *
       * <code>string role = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearRole() {
        
        role_ = getDefaultInstance().getRole();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Роль партнера, для которой создается плановый период.
       * В данный момент в данном поле могут приняты следующие значения:
       * * driver - курьер
       * * shopper - сборщик
       * * universal - универсал
       * </pre>
       *
       * <code>string role = 2;</code>
       * @param value The bytes for role to set.
       * @return This builder for chaining.
       */
      public Builder setRoleBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        role_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object startedAt_ = "";
      /**
       * <pre>
       * Дата и время начала планового периода. Формат значения RFC 3339
       * Пример данных: 2021-05-01T19:00:00+03:00
       * </pre>
       *
       * <code>string started_at = 3;</code>
       * @return The startedAt.
       */
      public java.lang.String getStartedAt() {
        java.lang.Object ref = startedAt_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          startedAt_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Дата и время начала планового периода. Формат значения RFC 3339
       * Пример данных: 2021-05-01T19:00:00+03:00
       * </pre>
       *
       * <code>string started_at = 3;</code>
       * @return The bytes for startedAt.
       */
      public com.google.protobuf.ByteString
          getStartedAtBytes() {
        java.lang.Object ref = startedAt_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          startedAt_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Дата и время начала планового периода. Формат значения RFC 3339
       * Пример данных: 2021-05-01T19:00:00+03:00
       * </pre>
       *
       * <code>string started_at = 3;</code>
       * @param value The startedAt to set.
       * @return This builder for chaining.
       */
      public Builder setStartedAt(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        startedAt_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Дата и время начала планового периода. Формат значения RFC 3339
       * Пример данных: 2021-05-01T19:00:00+03:00
       * </pre>
       *
       * <code>string started_at = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearStartedAt() {
        
        startedAt_ = getDefaultInstance().getStartedAt();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Дата и время начала планового периода. Формат значения RFC 3339
       * Пример данных: 2021-05-01T19:00:00+03:00
       * </pre>
       *
       * <code>string started_at = 3;</code>
       * @param value The bytes for startedAt to set.
       * @return This builder for chaining.
       */
      public Builder setStartedAtBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        startedAt_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object endedAt_ = "";
      /**
       * <pre>
       * Дата и время окончания планового периода. Формат значения RFC 3339
       * Пример данных: 2021-05-01T20:00:00+03:00
       * </pre>
       *
       * <code>string ended_at = 4;</code>
       * @return The endedAt.
       */
      public java.lang.String getEndedAt() {
        java.lang.Object ref = endedAt_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          endedAt_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Дата и время окончания планового периода. Формат значения RFC 3339
       * Пример данных: 2021-05-01T20:00:00+03:00
       * </pre>
       *
       * <code>string ended_at = 4;</code>
       * @return The bytes for endedAt.
       */
      public com.google.protobuf.ByteString
          getEndedAtBytes() {
        java.lang.Object ref = endedAt_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          endedAt_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Дата и время окончания планового периода. Формат значения RFC 3339
       * Пример данных: 2021-05-01T20:00:00+03:00
       * </pre>
       *
       * <code>string ended_at = 4;</code>
       * @param value The endedAt to set.
       * @return This builder for chaining.
       */
      public Builder setEndedAt(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        endedAt_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Дата и время окончания планового периода. Формат значения RFC 3339
       * Пример данных: 2021-05-01T20:00:00+03:00
       * </pre>
       *
       * <code>string ended_at = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearEndedAt() {
        
        endedAt_ = getDefaultInstance().getEndedAt();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Дата и время окончания планового периода. Формат значения RFC 3339
       * Пример данных: 2021-05-01T20:00:00+03:00
       * </pre>
       *
       * <code>string ended_at = 4;</code>
       * @param value The bytes for endedAt to set.
       * @return This builder for chaining.
       */
      public Builder setEndedAtBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        endedAt_ = value;
        onChanged();
        return this;
      }

      private int peoplesCount_ ;
      /**
       * <pre>
       * Количество партнеров в плановом периоде, которому гарантирована оплата.
       * </pre>
       *
       * <code>uint32 peoples_count = 5;</code>
       * @return The peoplesCount.
       */
      @java.lang.Override
      public int getPeoplesCount() {
        return peoplesCount_;
      }
      /**
       * <pre>
       * Количество партнеров в плановом периоде, которому гарантирована оплата.
       * </pre>
       *
       * <code>uint32 peoples_count = 5;</code>
       * @param value The peoplesCount to set.
       * @return This builder for chaining.
       */
      public Builder setPeoplesCount(int value) {
        
        peoplesCount_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Количество партнеров в плановом периоде, которому гарантирована оплата.
       * </pre>
       *
       * <code>uint32 peoples_count = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearPeoplesCount() {
        
        peoplesCount_ = 0;
        onChanged();
        return this;
      }

      private float baseGuaranteedPayroll_ ;
      /**
       * <pre>
       * Базовая гарантированная оплата - количество рублей в час, которые партнер
       * гарантированно получит за определенный час работы в смене.
       * </pre>
       *
       * <code>float base_guaranteed_payroll = 6;</code>
       * @return The baseGuaranteedPayroll.
       */
      @java.lang.Override
      public float getBaseGuaranteedPayroll() {
        return baseGuaranteedPayroll_;
      }
      /**
       * <pre>
       * Базовая гарантированная оплата - количество рублей в час, которые партнер
       * гарантированно получит за определенный час работы в смене.
       * </pre>
       *
       * <code>float base_guaranteed_payroll = 6;</code>
       * @param value The baseGuaranteedPayroll to set.
       * @return This builder for chaining.
       */
      public Builder setBaseGuaranteedPayroll(float value) {
        
        baseGuaranteedPayroll_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Базовая гарантированная оплата - количество рублей в час, которые партнер
       * гарантированно получит за определенный час работы в смене.
       * </pre>
       *
       * <code>float base_guaranteed_payroll = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearBaseGuaranteedPayroll() {
        
        baseGuaranteedPayroll_ = 0F;
        onChanged();
        return this;
      }

      private float basePredictedPayroll_ ;
      /**
       * <pre>
       * Прогнозируемая базовая оплата - прогнозируемая оплата, которую партнер может
       * получить за смену (включает гарантированную оплату)
       * </pre>
       *
       * <code>float base_predicted_payroll = 7;</code>
       * @return The basePredictedPayroll.
       */
      @java.lang.Override
      public float getBasePredictedPayroll() {
        return basePredictedPayroll_;
      }
      /**
       * <pre>
       * Прогнозируемая базовая оплата - прогнозируемая оплата, которую партнер может
       * получить за смену (включает гарантированную оплату)
       * </pre>
       *
       * <code>float base_predicted_payroll = 7;</code>
       * @param value The basePredictedPayroll to set.
       * @return This builder for chaining.
       */
      public Builder setBasePredictedPayroll(float value) {
        
        basePredictedPayroll_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Прогнозируемая базовая оплата - прогнозируемая оплата, которую партнер может
       * получить за смену (включает гарантированную оплату)
       * </pre>
       *
       * <code>float base_predicted_payroll = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearBasePredictedPayroll() {
        
        basePredictedPayroll_ = 0F;
        onChanged();
        return this;
      }

      private boolean surged_ ;
      /**
       * <pre>
       * Признак планового периода, показывающий что данные период является периодом повышенного
       * спроса и что в нем применяется повышенный коэффициент оплаты
       * </pre>
       *
       * <code>bool surged = 8;</code>
       * @return The surged.
       */
      @java.lang.Override
      public boolean getSurged() {
        return surged_;
      }
      /**
       * <pre>
       * Признак планового периода, показывающий что данные период является периодом повышенного
       * спроса и что в нем применяется повышенный коэффициент оплаты
       * </pre>
       *
       * <code>bool surged = 8;</code>
       * @param value The surged to set.
       * @return This builder for chaining.
       */
      public Builder setSurged(boolean value) {
        
        surged_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Признак планового периода, показывающий что данные период является периодом повышенного
       * спроса и что в нем применяется повышенный коэффициент оплаты
       * </pre>
       *
       * <code>bool surged = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearSurged() {
        
        surged_ = false;
        onChanged();
        return this;
      }

      private com.google.protobuf.Internal.IntList mappedShops_ = emptyIntList();
      private void ensureMappedShopsIsMutable() {
        if (!((bitField0_ & 0x00000001) != 0)) {
          mappedShops_ = mutableCopy(mappedShops_);
          bitField0_ |= 0x00000001;
         }
      }
      /**
       * <pre>
       * Список идентификаторов магазинов. Если список заполнен, то в рамках смены заказы поступают
       * только из указанных магазинов, если пуст, то со всех магазинов, доступных сервису диспетчеризации заказов
       * </pre>
       *
       * <code>repeated uint32 mapped_shops = 9;</code>
       * @return A list containing the mappedShops.
       */
      public java.util.List<java.lang.Integer>
          getMappedShopsList() {
        return ((bitField0_ & 0x00000001) != 0) ?
                 java.util.Collections.unmodifiableList(mappedShops_) : mappedShops_;
      }
      /**
       * <pre>
       * Список идентификаторов магазинов. Если список заполнен, то в рамках смены заказы поступают
       * только из указанных магазинов, если пуст, то со всех магазинов, доступных сервису диспетчеризации заказов
       * </pre>
       *
       * <code>repeated uint32 mapped_shops = 9;</code>
       * @return The count of mappedShops.
       */
      public int getMappedShopsCount() {
        return mappedShops_.size();
      }
      /**
       * <pre>
       * Список идентификаторов магазинов. Если список заполнен, то в рамках смены заказы поступают
       * только из указанных магазинов, если пуст, то со всех магазинов, доступных сервису диспетчеризации заказов
       * </pre>
       *
       * <code>repeated uint32 mapped_shops = 9;</code>
       * @param index The index of the element to return.
       * @return The mappedShops at the given index.
       */
      public int getMappedShops(int index) {
        return mappedShops_.getInt(index);
      }
      /**
       * <pre>
       * Список идентификаторов магазинов. Если список заполнен, то в рамках смены заказы поступают
       * только из указанных магазинов, если пуст, то со всех магазинов, доступных сервису диспетчеризации заказов
       * </pre>
       *
       * <code>repeated uint32 mapped_shops = 9;</code>
       * @param index The index to set the value at.
       * @param value The mappedShops to set.
       * @return This builder for chaining.
       */
      public Builder setMappedShops(
          int index, int value) {
        ensureMappedShopsIsMutable();
        mappedShops_.setInt(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Список идентификаторов магазинов. Если список заполнен, то в рамках смены заказы поступают
       * только из указанных магазинов, если пуст, то со всех магазинов, доступных сервису диспетчеризации заказов
       * </pre>
       *
       * <code>repeated uint32 mapped_shops = 9;</code>
       * @param value The mappedShops to add.
       * @return This builder for chaining.
       */
      public Builder addMappedShops(int value) {
        ensureMappedShopsIsMutable();
        mappedShops_.addInt(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Список идентификаторов магазинов. Если список заполнен, то в рамках смены заказы поступают
       * только из указанных магазинов, если пуст, то со всех магазинов, доступных сервису диспетчеризации заказов
       * </pre>
       *
       * <code>repeated uint32 mapped_shops = 9;</code>
       * @param values The mappedShops to add.
       * @return This builder for chaining.
       */
      public Builder addAllMappedShops(
          java.lang.Iterable<? extends java.lang.Integer> values) {
        ensureMappedShopsIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, mappedShops_);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Список идентификаторов магазинов. Если список заполнен, то в рамках смены заказы поступают
       * только из указанных магазинов, если пуст, то со всех магазинов, доступных сервису диспетчеризации заказов
       * </pre>
       *
       * <code>repeated uint32 mapped_shops = 9;</code>
       * @return This builder for chaining.
       */
      public Builder clearMappedShops() {
        mappedShops_ = emptyIntList();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }

      private boolean isActive_ ;
      /**
       * <pre>
       * Признак активности планового периода
       * </pre>
       *
       * <code>bool is_active = 10;</code>
       * @return The isActive.
       */
      @java.lang.Override
      public boolean getIsActive() {
        return isActive_;
      }
      /**
       * <pre>
       * Признак активности планового периода
       * </pre>
       *
       * <code>bool is_active = 10;</code>
       * @param value The isActive to set.
       * @return This builder for chaining.
       */
      public Builder setIsActive(boolean value) {
        
        isActive_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Признак активности планового периода
       * </pre>
       *
       * <code>bool is_active = 10;</code>
       * @return This builder for chaining.
       */
      public Builder clearIsActive() {
        
        isActive_ = false;
        onChanged();
        return this;
      }

      private int storeId_ ;
      /**
       * <pre>
       * Магазин для плановой доставки
       * </pre>
       *
       * <code>uint32 store_id = 11;</code>
       * @return The storeId.
       */
      @java.lang.Override
      public int getStoreId() {
        return storeId_;
      }
      /**
       * <pre>
       * Магазин для плановой доставки
       * </pre>
       *
       * <code>uint32 store_id = 11;</code>
       * @param value The storeId to set.
       * @return This builder for chaining.
       */
      public Builder setStoreId(int value) {
        
        storeId_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Магазин для плановой доставки
       * </pre>
       *
       * <code>uint32 store_id = 11;</code>
       * @return This builder for chaining.
       */
      public Builder clearStoreId() {
        
        storeId_ = 0;
        onChanged();
        return this;
      }

      private com.google.protobuf.MapField<
          java.lang.String, java.lang.Float> guaranteedPayroll_;
      private com.google.protobuf.MapField<java.lang.String, java.lang.Float>
      internalGetGuaranteedPayroll() {
        if (guaranteedPayroll_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              GuaranteedPayrollDefaultEntryHolder.defaultEntry);
        }
        return guaranteedPayroll_;
      }
      private com.google.protobuf.MapField<java.lang.String, java.lang.Float>
      internalGetMutableGuaranteedPayroll() {
        onChanged();;
        if (guaranteedPayroll_ == null) {
          guaranteedPayroll_ = com.google.protobuf.MapField.newMapField(
              GuaranteedPayrollDefaultEntryHolder.defaultEntry);
        }
        if (!guaranteedPayroll_.isMutable()) {
          guaranteedPayroll_ = guaranteedPayroll_.copy();
        }
        return guaranteedPayroll_;
      }

      public int getGuaranteedPayrollCount() {
        return internalGetGuaranteedPayroll().getMap().size();
      }
      /**
       * <pre>
       * Объект с базовыми гарантированными оплатами по различным ролям - количество рублей в час, которые партнер
       * гарантированно получит за определенный час работы в смене.
       * </pre>
       *
       * <code>map&lt;string, float&gt; guaranteed_payroll = 12;</code>
       */

      @java.lang.Override
      public boolean containsGuaranteedPayroll(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        return internalGetGuaranteedPayroll().getMap().containsKey(key);
      }
      /**
       * Use {@link #getGuaranteedPayrollMap()} instead.
       */
      @java.lang.Override
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.Float> getGuaranteedPayroll() {
        return getGuaranteedPayrollMap();
      }
      /**
       * <pre>
       * Объект с базовыми гарантированными оплатами по различным ролям - количество рублей в час, которые партнер
       * гарантированно получит за определенный час работы в смене.
       * </pre>
       *
       * <code>map&lt;string, float&gt; guaranteed_payroll = 12;</code>
       */
      @java.lang.Override

      public java.util.Map<java.lang.String, java.lang.Float> getGuaranteedPayrollMap() {
        return internalGetGuaranteedPayroll().getMap();
      }
      /**
       * <pre>
       * Объект с базовыми гарантированными оплатами по различным ролям - количество рублей в час, которые партнер
       * гарантированно получит за определенный час работы в смене.
       * </pre>
       *
       * <code>map&lt;string, float&gt; guaranteed_payroll = 12;</code>
       */
      @java.lang.Override

      public float getGuaranteedPayrollOrDefault(
          java.lang.String key,
          float defaultValue) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.Float> map =
            internalGetGuaranteedPayroll().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * Объект с базовыми гарантированными оплатами по различным ролям - количество рублей в час, которые партнер
       * гарантированно получит за определенный час работы в смене.
       * </pre>
       *
       * <code>map&lt;string, float&gt; guaranteed_payroll = 12;</code>
       */
      @java.lang.Override

      public float getGuaranteedPayrollOrThrow(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.Float> map =
            internalGetGuaranteedPayroll().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearGuaranteedPayroll() {
        internalGetMutableGuaranteedPayroll().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * Объект с базовыми гарантированными оплатами по различным ролям - количество рублей в час, которые партнер
       * гарантированно получит за определенный час работы в смене.
       * </pre>
       *
       * <code>map&lt;string, float&gt; guaranteed_payroll = 12;</code>
       */

      public Builder removeGuaranteedPayroll(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableGuaranteedPayroll().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.Float>
      getMutableGuaranteedPayroll() {
        return internalGetMutableGuaranteedPayroll().getMutableMap();
      }
      /**
       * <pre>
       * Объект с базовыми гарантированными оплатами по различным ролям - количество рублей в час, которые партнер
       * гарантированно получит за определенный час работы в смене.
       * </pre>
       *
       * <code>map&lt;string, float&gt; guaranteed_payroll = 12;</code>
       */
      public Builder putGuaranteedPayroll(
          java.lang.String key,
          float value) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        
        internalGetMutableGuaranteedPayroll().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <pre>
       * Объект с базовыми гарантированными оплатами по различным ролям - количество рублей в час, которые партнер
       * гарантированно получит за определенный час работы в смене.
       * </pre>
       *
       * <code>map&lt;string, float&gt; guaranteed_payroll = 12;</code>
       */

      public Builder putAllGuaranteedPayroll(
          java.util.Map<java.lang.String, java.lang.Float> values) {
        internalGetMutableGuaranteedPayroll().getMutableMap()
            .putAll(values);
        return this;
      }

      private com.google.protobuf.MapField<
          java.lang.String, java.lang.Float> predictedPayroll_;
      private com.google.protobuf.MapField<java.lang.String, java.lang.Float>
      internalGetPredictedPayroll() {
        if (predictedPayroll_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              PredictedPayrollDefaultEntryHolder.defaultEntry);
        }
        return predictedPayroll_;
      }
      private com.google.protobuf.MapField<java.lang.String, java.lang.Float>
      internalGetMutablePredictedPayroll() {
        onChanged();;
        if (predictedPayroll_ == null) {
          predictedPayroll_ = com.google.protobuf.MapField.newMapField(
              PredictedPayrollDefaultEntryHolder.defaultEntry);
        }
        if (!predictedPayroll_.isMutable()) {
          predictedPayroll_ = predictedPayroll_.copy();
        }
        return predictedPayroll_;
      }

      public int getPredictedPayrollCount() {
        return internalGetPredictedPayroll().getMap().size();
      }
      /**
       * <pre>
       * Объект с прогнозируемой базовой оплатой по различным ролям - прогнозируемая оплата, которую партнер может
       * получить за смену (включает гарантированную оплату)
       * </pre>
       *
       * <code>map&lt;string, float&gt; predicted_payroll = 13;</code>
       */

      @java.lang.Override
      public boolean containsPredictedPayroll(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        return internalGetPredictedPayroll().getMap().containsKey(key);
      }
      /**
       * Use {@link #getPredictedPayrollMap()} instead.
       */
      @java.lang.Override
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.Float> getPredictedPayroll() {
        return getPredictedPayrollMap();
      }
      /**
       * <pre>
       * Объект с прогнозируемой базовой оплатой по различным ролям - прогнозируемая оплата, которую партнер может
       * получить за смену (включает гарантированную оплату)
       * </pre>
       *
       * <code>map&lt;string, float&gt; predicted_payroll = 13;</code>
       */
      @java.lang.Override

      public java.util.Map<java.lang.String, java.lang.Float> getPredictedPayrollMap() {
        return internalGetPredictedPayroll().getMap();
      }
      /**
       * <pre>
       * Объект с прогнозируемой базовой оплатой по различным ролям - прогнозируемая оплата, которую партнер может
       * получить за смену (включает гарантированную оплату)
       * </pre>
       *
       * <code>map&lt;string, float&gt; predicted_payroll = 13;</code>
       */
      @java.lang.Override

      public float getPredictedPayrollOrDefault(
          java.lang.String key,
          float defaultValue) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.Float> map =
            internalGetPredictedPayroll().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * Объект с прогнозируемой базовой оплатой по различным ролям - прогнозируемая оплата, которую партнер может
       * получить за смену (включает гарантированную оплату)
       * </pre>
       *
       * <code>map&lt;string, float&gt; predicted_payroll = 13;</code>
       */
      @java.lang.Override

      public float getPredictedPayrollOrThrow(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.Float> map =
            internalGetPredictedPayroll().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearPredictedPayroll() {
        internalGetMutablePredictedPayroll().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * Объект с прогнозируемой базовой оплатой по различным ролям - прогнозируемая оплата, которую партнер может
       * получить за смену (включает гарантированную оплату)
       * </pre>
       *
       * <code>map&lt;string, float&gt; predicted_payroll = 13;</code>
       */

      public Builder removePredictedPayroll(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        internalGetMutablePredictedPayroll().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.Float>
      getMutablePredictedPayroll() {
        return internalGetMutablePredictedPayroll().getMutableMap();
      }
      /**
       * <pre>
       * Объект с прогнозируемой базовой оплатой по различным ролям - прогнозируемая оплата, которую партнер может
       * получить за смену (включает гарантированную оплату)
       * </pre>
       *
       * <code>map&lt;string, float&gt; predicted_payroll = 13;</code>
       */
      public Builder putPredictedPayroll(
          java.lang.String key,
          float value) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        
        internalGetMutablePredictedPayroll().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <pre>
       * Объект с прогнозируемой базовой оплатой по различным ролям - прогнозируемая оплата, которую партнер может
       * получить за смену (включает гарантированную оплату)
       * </pre>
       *
       * <code>map&lt;string, float&gt; predicted_payroll = 13;</code>
       */

      public Builder putAllPredictedPayroll(
          java.util.Map<java.lang.String, java.lang.Float> values) {
        internalGetMutablePredictedPayroll().getMutableMap()
            .putAll(values);
        return this;
      }

      private com.google.protobuf.Timestamp publishedTime_;
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.Timestamp, com.google.protobuf.Timestamp.Builder, com.google.protobuf.TimestampOrBuilder> publishedTimeBuilder_;
      /**
       * <pre>
       * Глобальное время публикации UTC планового периода для партнера
       * </pre>
       *
       * <code>.google.protobuf.Timestamp published_time = 14;</code>
       * @return Whether the publishedTime field is set.
       */
      public boolean hasPublishedTime() {
        return publishedTimeBuilder_ != null || publishedTime_ != null;
      }
      /**
       * <pre>
       * Глобальное время публикации UTC планового периода для партнера
       * </pre>
       *
       * <code>.google.protobuf.Timestamp published_time = 14;</code>
       * @return The publishedTime.
       */
      public com.google.protobuf.Timestamp getPublishedTime() {
        if (publishedTimeBuilder_ == null) {
          return publishedTime_ == null ? com.google.protobuf.Timestamp.getDefaultInstance() : publishedTime_;
        } else {
          return publishedTimeBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Глобальное время публикации UTC планового периода для партнера
       * </pre>
       *
       * <code>.google.protobuf.Timestamp published_time = 14;</code>
       */
      public Builder setPublishedTime(com.google.protobuf.Timestamp value) {
        if (publishedTimeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          publishedTime_ = value;
          onChanged();
        } else {
          publishedTimeBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Глобальное время публикации UTC планового периода для партнера
       * </pre>
       *
       * <code>.google.protobuf.Timestamp published_time = 14;</code>
       */
      public Builder setPublishedTime(
          com.google.protobuf.Timestamp.Builder builderForValue) {
        if (publishedTimeBuilder_ == null) {
          publishedTime_ = builderForValue.build();
          onChanged();
        } else {
          publishedTimeBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Глобальное время публикации UTC планового периода для партнера
       * </pre>
       *
       * <code>.google.protobuf.Timestamp published_time = 14;</code>
       */
      public Builder mergePublishedTime(com.google.protobuf.Timestamp value) {
        if (publishedTimeBuilder_ == null) {
          if (publishedTime_ != null) {
            publishedTime_ =
              com.google.protobuf.Timestamp.newBuilder(publishedTime_).mergeFrom(value).buildPartial();
          } else {
            publishedTime_ = value;
          }
          onChanged();
        } else {
          publishedTimeBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Глобальное время публикации UTC планового периода для партнера
       * </pre>
       *
       * <code>.google.protobuf.Timestamp published_time = 14;</code>
       */
      public Builder clearPublishedTime() {
        if (publishedTimeBuilder_ == null) {
          publishedTime_ = null;
          onChanged();
        } else {
          publishedTime_ = null;
          publishedTimeBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Глобальное время публикации UTC планового периода для партнера
       * </pre>
       *
       * <code>.google.protobuf.Timestamp published_time = 14;</code>
       */
      public com.google.protobuf.Timestamp.Builder getPublishedTimeBuilder() {
        
        onChanged();
        return getPublishedTimeFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Глобальное время публикации UTC планового периода для партнера
       * </pre>
       *
       * <code>.google.protobuf.Timestamp published_time = 14;</code>
       */
      public com.google.protobuf.TimestampOrBuilder getPublishedTimeOrBuilder() {
        if (publishedTimeBuilder_ != null) {
          return publishedTimeBuilder_.getMessageOrBuilder();
        } else {
          return publishedTime_ == null ?
              com.google.protobuf.Timestamp.getDefaultInstance() : publishedTime_;
        }
      }
      /**
       * <pre>
       * Глобальное время публикации UTC планового периода для партнера
       * </pre>
       *
       * <code>.google.protobuf.Timestamp published_time = 14;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.Timestamp, com.google.protobuf.Timestamp.Builder, com.google.protobuf.TimestampOrBuilder> 
          getPublishedTimeFieldBuilder() {
        if (publishedTimeBuilder_ == null) {
          publishedTimeBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.google.protobuf.Timestamp, com.google.protobuf.Timestamp.Builder, com.google.protobuf.TimestampOrBuilder>(
                  getPublishedTime(),
                  getParentForChildren(),
                  isClean());
          publishedTime_ = null;
        }
        return publishedTimeBuilder_;
      }

      private com.google.protobuf.MapField<
          java.lang.String, java.lang.String> publishedTimes_;
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetPublishedTimes() {
        if (publishedTimes_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              PublishedTimesDefaultEntryHolder.defaultEntry);
        }
        return publishedTimes_;
      }
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetMutablePublishedTimes() {
        onChanged();;
        if (publishedTimes_ == null) {
          publishedTimes_ = com.google.protobuf.MapField.newMapField(
              PublishedTimesDefaultEntryHolder.defaultEntry);
        }
        if (!publishedTimes_.isMutable()) {
          publishedTimes_ = publishedTimes_.copy();
        }
        return publishedTimes_;
      }

      public int getPublishedTimesCount() {
        return internalGetPublishedTimes().getMap().size();
      }
      /**
       * <pre>
       * Объект с тегом и временем публикации планового периода для партнера
       * Пример данных: {"good_guy": "2021-05-01T19:00:00+03:00"}
       * </pre>
       *
       * <code>map&lt;string, string&gt; published_times = 15;</code>
       */

      @java.lang.Override
      public boolean containsPublishedTimes(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        return internalGetPublishedTimes().getMap().containsKey(key);
      }
      /**
       * Use {@link #getPublishedTimesMap()} instead.
       */
      @java.lang.Override
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String> getPublishedTimes() {
        return getPublishedTimesMap();
      }
      /**
       * <pre>
       * Объект с тегом и временем публикации планового периода для партнера
       * Пример данных: {"good_guy": "2021-05-01T19:00:00+03:00"}
       * </pre>
       *
       * <code>map&lt;string, string&gt; published_times = 15;</code>
       */
      @java.lang.Override

      public java.util.Map<java.lang.String, java.lang.String> getPublishedTimesMap() {
        return internalGetPublishedTimes().getMap();
      }
      /**
       * <pre>
       * Объект с тегом и временем публикации планового периода для партнера
       * Пример данных: {"good_guy": "2021-05-01T19:00:00+03:00"}
       * </pre>
       *
       * <code>map&lt;string, string&gt; published_times = 15;</code>
       */
      @java.lang.Override

      public java.lang.String getPublishedTimesOrDefault(
          java.lang.String key,
          java.lang.String defaultValue) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetPublishedTimes().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * Объект с тегом и временем публикации планового периода для партнера
       * Пример данных: {"good_guy": "2021-05-01T19:00:00+03:00"}
       * </pre>
       *
       * <code>map&lt;string, string&gt; published_times = 15;</code>
       */
      @java.lang.Override

      public java.lang.String getPublishedTimesOrThrow(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetPublishedTimes().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearPublishedTimes() {
        internalGetMutablePublishedTimes().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * Объект с тегом и временем публикации планового периода для партнера
       * Пример данных: {"good_guy": "2021-05-01T19:00:00+03:00"}
       * </pre>
       *
       * <code>map&lt;string, string&gt; published_times = 15;</code>
       */

      public Builder removePublishedTimes(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        internalGetMutablePublishedTimes().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String>
      getMutablePublishedTimes() {
        return internalGetMutablePublishedTimes().getMutableMap();
      }
      /**
       * <pre>
       * Объект с тегом и временем публикации планового периода для партнера
       * Пример данных: {"good_guy": "2021-05-01T19:00:00+03:00"}
       * </pre>
       *
       * <code>map&lt;string, string&gt; published_times = 15;</code>
       */
      public Builder putPublishedTimes(
          java.lang.String key,
          java.lang.String value) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        if (value == null) { throw new java.lang.NullPointerException(); }
        internalGetMutablePublishedTimes().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <pre>
       * Объект с тегом и временем публикации планового периода для партнера
       * Пример данных: {"good_guy": "2021-05-01T19:00:00+03:00"}
       * </pre>
       *
       * <code>map&lt;string, string&gt; published_times = 15;</code>
       */

      public Builder putAllPublishedTimes(
          java.util.Map<java.lang.String, java.lang.String> values) {
        internalGetMutablePublishedTimes().getMutableMap()
            .putAll(values);
        return this;
      }

      private int peoplesCountPredicted_ ;
      /**
       * <pre>
       * Предполагаемое количество партнеров в плановом периоде, которым гарантирована оплата.
       * </pre>
       *
       * <code>uint32 peoples_count_predicted = 16;</code>
       * @return The peoplesCountPredicted.
       */
      @java.lang.Override
      public int getPeoplesCountPredicted() {
        return peoplesCountPredicted_;
      }
      /**
       * <pre>
       * Предполагаемое количество партнеров в плановом периоде, которым гарантирована оплата.
       * </pre>
       *
       * <code>uint32 peoples_count_predicted = 16;</code>
       * @param value The peoplesCountPredicted to set.
       * @return This builder for chaining.
       */
      public Builder setPeoplesCountPredicted(int value) {
        
        peoplesCountPredicted_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Предполагаемое количество партнеров в плановом периоде, которым гарантирована оплата.
       * </pre>
       *
       * <code>uint32 peoples_count_predicted = 16;</code>
       * @return This builder for chaining.
       */
      public Builder clearPeoplesCountPredicted() {
        
        peoplesCountPredicted_ = 0;
        onChanged();
        return this;
      }

      private com.google.protobuf.UInt32Value maxPeoplesCount_;
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder> maxPeoplesCountBuilder_;
      /**
       * <pre>
       * Максимальное количество человек, которые могут взять планируемый период
       * Если отсутствует (nil/пустое), то ограничение не применяется
       * </pre>
       *
       * <code>.google.protobuf.UInt32Value max_peoples_count = 17;</code>
       * @return Whether the maxPeoplesCount field is set.
       */
      public boolean hasMaxPeoplesCount() {
        return maxPeoplesCountBuilder_ != null || maxPeoplesCount_ != null;
      }
      /**
       * <pre>
       * Максимальное количество человек, которые могут взять планируемый период
       * Если отсутствует (nil/пустое), то ограничение не применяется
       * </pre>
       *
       * <code>.google.protobuf.UInt32Value max_peoples_count = 17;</code>
       * @return The maxPeoplesCount.
       */
      public com.google.protobuf.UInt32Value getMaxPeoplesCount() {
        if (maxPeoplesCountBuilder_ == null) {
          return maxPeoplesCount_ == null ? com.google.protobuf.UInt32Value.getDefaultInstance() : maxPeoplesCount_;
        } else {
          return maxPeoplesCountBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Максимальное количество человек, которые могут взять планируемый период
       * Если отсутствует (nil/пустое), то ограничение не применяется
       * </pre>
       *
       * <code>.google.protobuf.UInt32Value max_peoples_count = 17;</code>
       */
      public Builder setMaxPeoplesCount(com.google.protobuf.UInt32Value value) {
        if (maxPeoplesCountBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          maxPeoplesCount_ = value;
          onChanged();
        } else {
          maxPeoplesCountBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Максимальное количество человек, которые могут взять планируемый период
       * Если отсутствует (nil/пустое), то ограничение не применяется
       * </pre>
       *
       * <code>.google.protobuf.UInt32Value max_peoples_count = 17;</code>
       */
      public Builder setMaxPeoplesCount(
          com.google.protobuf.UInt32Value.Builder builderForValue) {
        if (maxPeoplesCountBuilder_ == null) {
          maxPeoplesCount_ = builderForValue.build();
          onChanged();
        } else {
          maxPeoplesCountBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Максимальное количество человек, которые могут взять планируемый период
       * Если отсутствует (nil/пустое), то ограничение не применяется
       * </pre>
       *
       * <code>.google.protobuf.UInt32Value max_peoples_count = 17;</code>
       */
      public Builder mergeMaxPeoplesCount(com.google.protobuf.UInt32Value value) {
        if (maxPeoplesCountBuilder_ == null) {
          if (maxPeoplesCount_ != null) {
            maxPeoplesCount_ =
              com.google.protobuf.UInt32Value.newBuilder(maxPeoplesCount_).mergeFrom(value).buildPartial();
          } else {
            maxPeoplesCount_ = value;
          }
          onChanged();
        } else {
          maxPeoplesCountBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Максимальное количество человек, которые могут взять планируемый период
       * Если отсутствует (nil/пустое), то ограничение не применяется
       * </pre>
       *
       * <code>.google.protobuf.UInt32Value max_peoples_count = 17;</code>
       */
      public Builder clearMaxPeoplesCount() {
        if (maxPeoplesCountBuilder_ == null) {
          maxPeoplesCount_ = null;
          onChanged();
        } else {
          maxPeoplesCount_ = null;
          maxPeoplesCountBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Максимальное количество человек, которые могут взять планируемый период
       * Если отсутствует (nil/пустое), то ограничение не применяется
       * </pre>
       *
       * <code>.google.protobuf.UInt32Value max_peoples_count = 17;</code>
       */
      public com.google.protobuf.UInt32Value.Builder getMaxPeoplesCountBuilder() {
        
        onChanged();
        return getMaxPeoplesCountFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Максимальное количество человек, которые могут взять планируемый период
       * Если отсутствует (nil/пустое), то ограничение не применяется
       * </pre>
       *
       * <code>.google.protobuf.UInt32Value max_peoples_count = 17;</code>
       */
      public com.google.protobuf.UInt32ValueOrBuilder getMaxPeoplesCountOrBuilder() {
        if (maxPeoplesCountBuilder_ != null) {
          return maxPeoplesCountBuilder_.getMessageOrBuilder();
        } else {
          return maxPeoplesCount_ == null ?
              com.google.protobuf.UInt32Value.getDefaultInstance() : maxPeoplesCount_;
        }
      }
      /**
       * <pre>
       * Максимальное количество человек, которые могут взять планируемый период
       * Если отсутствует (nil/пустое), то ограничение не применяется
       * </pre>
       *
       * <code>.google.protobuf.UInt32Value max_peoples_count = 17;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder> 
          getMaxPeoplesCountFieldBuilder() {
        if (maxPeoplesCountBuilder_ == null) {
          maxPeoplesCountBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder>(
                  getMaxPeoplesCount(),
                  getParentForChildren(),
                  isClean());
          maxPeoplesCount_ = null;
        }
        return maxPeoplesCountBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:shifts.PlanningPeriodItem)
    }

    // @@protoc_insertion_point(class_scope:shifts.PlanningPeriodItem)
    private static final shifts.ImportPlanningPeriods.PlanningPeriodItem DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new shifts.ImportPlanningPeriods.PlanningPeriodItem();
    }

    public static shifts.ImportPlanningPeriods.PlanningPeriodItem getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<PlanningPeriodItem>
        PARSER = new com.google.protobuf.AbstractParser<PlanningPeriodItem>() {
      @java.lang.Override
      public PlanningPeriodItem parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new PlanningPeriodItem(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<PlanningPeriodItem> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<PlanningPeriodItem> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public shifts.ImportPlanningPeriods.PlanningPeriodItem getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_shifts_PlaningPeriodsImport_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_shifts_PlaningPeriodsImport_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_shifts_PlanningPeriodItem_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_shifts_PlanningPeriodItem_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_shifts_PlanningPeriodItem_GuaranteedPayrollEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_shifts_PlanningPeriodItem_GuaranteedPayrollEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_shifts_PlanningPeriodItem_PredictedPayrollEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_shifts_PlanningPeriodItem_PredictedPayrollEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_shifts_PlanningPeriodItem_PublishedTimesEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_shifts_PlanningPeriodItem_PublishedTimesEntry_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static  com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n\'on_demand/import_planning_periods.prot" +
      "o\022\006shifts\032\037google/protobuf/timestamp.pro" +
      "to\032\036google/protobuf/wrappers.proto\"i\n\024Pl" +
      "aningPeriodsImport\022\n\n\002id\030\001 \001(\t\022\017\n\007sent_a" +
      "t\030\002 \001(\t\0224\n\020planning_periods\030\003 \003(\0132\032.shif" +
      "ts.PlanningPeriodItem\"\242\006\n\022PlanningPeriod" +
      "Item\022\030\n\020planning_area_id\030\001 \001(\r\022\014\n\004role\030\002" +
      " \001(\t\022\022\n\nstarted_at\030\003 \001(\t\022\020\n\010ended_at\030\004 \001" +
      "(\t\022\025\n\rpeoples_count\030\005 \001(\r\022\037\n\027base_guaran" +
      "teed_payroll\030\006 \001(\002\022\036\n\026base_predicted_pay" +
      "roll\030\007 \001(\002\022\016\n\006surged\030\010 \001(\010\022\024\n\014mapped_sho" +
      "ps\030\t \003(\r\022\021\n\tis_active\030\n \001(\010\022\020\n\010store_id\030" +
      "\013 \001(\r\022M\n\022guaranteed_payroll\030\014 \003(\01321.shif" +
      "ts.PlanningPeriodItem.GuaranteedPayrollE" +
      "ntry\022K\n\021predicted_payroll\030\r \003(\01320.shifts" +
      ".PlanningPeriodItem.PredictedPayrollEntr" +
      "y\0222\n\016published_time\030\016 \001(\0132\032.google.proto" +
      "buf.Timestamp\022G\n\017published_times\030\017 \003(\0132." +
      ".shifts.PlanningPeriodItem.PublishedTime" +
      "sEntry\022\037\n\027peoples_count_predicted\030\020 \001(\r\022" +
      "7\n\021max_peoples_count\030\021 \001(\0132\034.google.prot" +
      "obuf.UInt32Value\0328\n\026GuaranteedPayrollEnt" +
      "ry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\002:\0028\001\0327\n\025Pr" +
      "edictedPayrollEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005valu" +
      "e\030\002 \001(\002:\0028\001\0325\n\023PublishedTimesEntry\022\013\n\003ke" +
      "y\030\001 \001(\t\022\r\n\005value\030\002 \001(\t:\0028\001BFZDgitlab.sbm" +
      "t.io/paas/content/operations/shifts/pkg/" +
      "server/grpc/shiftsb\006proto3"
    };
    descriptor = com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
          com.google.protobuf.TimestampProto.getDescriptor(),
          com.google.protobuf.WrappersProto.getDescriptor(),
        });
    internal_static_shifts_PlaningPeriodsImport_descriptor =
      getDescriptor().getMessageTypes().get(0);
    internal_static_shifts_PlaningPeriodsImport_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_shifts_PlaningPeriodsImport_descriptor,
        new java.lang.String[] { "Id", "SentAt", "PlanningPeriods", });
    internal_static_shifts_PlanningPeriodItem_descriptor =
      getDescriptor().getMessageTypes().get(1);
    internal_static_shifts_PlanningPeriodItem_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_shifts_PlanningPeriodItem_descriptor,
        new java.lang.String[] { "PlanningAreaId", "Role", "StartedAt", "EndedAt", "PeoplesCount", "BaseGuaranteedPayroll", "BasePredictedPayroll", "Surged", "MappedShops", "IsActive", "StoreId", "GuaranteedPayroll", "PredictedPayroll", "PublishedTime", "PublishedTimes", "PeoplesCountPredicted", "MaxPeoplesCount", });
    internal_static_shifts_PlanningPeriodItem_GuaranteedPayrollEntry_descriptor =
      internal_static_shifts_PlanningPeriodItem_descriptor.getNestedTypes().get(0);
    internal_static_shifts_PlanningPeriodItem_GuaranteedPayrollEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_shifts_PlanningPeriodItem_GuaranteedPayrollEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_shifts_PlanningPeriodItem_PredictedPayrollEntry_descriptor =
      internal_static_shifts_PlanningPeriodItem_descriptor.getNestedTypes().get(1);
    internal_static_shifts_PlanningPeriodItem_PredictedPayrollEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_shifts_PlanningPeriodItem_PredictedPayrollEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_shifts_PlanningPeriodItem_PublishedTimesEntry_descriptor =
      internal_static_shifts_PlanningPeriodItem_descriptor.getNestedTypes().get(2);
    internal_static_shifts_PlanningPeriodItem_PublishedTimesEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_shifts_PlanningPeriodItem_PublishedTimesEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    com.google.protobuf.TimestampProto.getDescriptor();
    com.google.protobuf.WrappersProto.getDescriptor();
  }

  // @@protoc_insertion_point(outer_class_scope)
}
